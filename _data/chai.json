[
  {
    "tags": [],
    "description": {
      "full": "chai\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "chai\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5,
    "codeStart": 11,
    "code": "var used = []\n  , exports = module.exports = {};",
    "ctx": {
      "type": "declaration",
      "name": "used",
      "value": "[]",
      "string": "used"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai version",
      "summary": "Chai version",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 14,
    "codeStart": 18,
    "code": "exports.version = '3.5.0';",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "version",
      "value": "'3.5.0'",
      "string": "exports.version"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Assertion Error",
      "summary": "Assertion Error",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 20,
    "codeStart": 24,
    "code": "exports.AssertionError = require('assertion-error');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "AssertionError",
      "value": "require('assertion-error')",
      "string": "exports.AssertionError"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Utils for plugins (not exported)",
      "summary": "Utils for plugins (not exported)",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 26,
    "codeStart": 30,
    "code": "var util = require('./chai/utils');",
    "ctx": {
      "type": "declaration",
      "name": "util",
      "value": "require('./chai/utils')",
      "string": "util"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Function}",
        "name": "",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{this} for chaining",
        "types": [
          "this"
        ],
        "typesDescription": "<a href=\"this.html\">this</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "for chaining"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "# .use(function)\n\nProvides a way to extend the internals of Chai",
      "summary": "# .use(function)",
      "body": "Provides a way to extend the internals of Chai"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 32,
    "codeStart": 42,
    "code": "exports.use = function (fn) {\n  if (!~used.indexOf(fn)) {\n    fn(this, util);\n    used.push(fn);\n  }\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "use",
      "string": "exports.use()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Utility Functions",
      "summary": "Utility Functions",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 51,
    "codeStart": 55,
    "code": "exports.util = util;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "util",
      "value": "util",
      "string": "exports.util"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Configuration",
      "summary": "Configuration",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 57,
    "codeStart": 61,
    "code": "var config = require('./chai/config');\nexports.config = config;",
    "ctx": {
      "type": "declaration",
      "name": "config",
      "value": "require('./chai/config')",
      "string": "config"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Primary `Assertion` prototype",
      "summary": "Primary `Assertion` prototype",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 64,
    "codeStart": 68,
    "code": "var assertion = require('./chai/assertion');\nexports.use(assertion);",
    "ctx": {
      "type": "declaration",
      "name": "assertion",
      "value": "require('./chai/assertion')",
      "string": "assertion"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Core Assertions",
      "summary": "Core Assertions",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 71,
    "codeStart": 75,
    "code": "var core = require('./chai/core/assertions');\nexports.use(core);",
    "ctx": {
      "type": "declaration",
      "name": "core",
      "value": "require('./chai/core/assertions')",
      "string": "core"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Expect interface",
      "summary": "Expect interface",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 78,
    "codeStart": 82,
    "code": "var expect = require('./chai/interface/expect');\nexports.use(expect);",
    "ctx": {
      "type": "declaration",
      "name": "expect",
      "value": "require('./chai/interface/expect')",
      "string": "expect"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Should interface",
      "summary": "Should interface",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 85,
    "codeStart": 89,
    "code": "var should = require('./chai/interface/should');\nexports.use(should);",
    "ctx": {
      "type": "declaration",
      "name": "should",
      "value": "require('./chai/interface/should')",
      "string": "should"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Assert interface",
      "summary": "Assert interface",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 92,
    "codeStart": 96,
    "code": "var assert = require('./chai/interface/assert');\nexports.use(assert);\n\n},{\"./chai/assertion\":3,\"./chai/config\":4,\"./chai/core/assertions\":5,\"./chai/interface/assert\":6,\"./chai/interface/expect\":7,\"./chai/interface/should\":8,\"./chai/utils\":22,\"assertion-error\":30}],3:[function(require,module,exports){",
    "ctx": {
      "type": "declaration",
      "name": "assert",
      "value": "require('./chai/interface/assert')",
      "string": "assert"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "chai\nhttp://chaijs.com\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "chai\nhttp://chaijs.com\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 100,
    "codeStart": 107,
    "code": "var config = require('./config');\n\nmodule.exports = function (_chai, util) {",
    "ctx": {
      "type": "declaration",
      "name": "config",
      "value": "require('./config')",
      "string": "config"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Module dependencies.",
      "summary": "Module dependencies.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 110,
    "codeStart": 114,
    "code": "var AssertionError = _chai.AssertionError\n  , flag = util.flag;",
    "ctx": {
      "type": "declaration",
      "name": "AssertionError",
      "value": "_chai.AssertionError",
      "string": "AssertionError"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Module export.",
      "summary": "Module export.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 117,
    "codeStart": 121,
    "code": "_chai.Assertion = Assertion;",
    "ctx": {
      "type": "property",
      "receiver": "_chai",
      "name": "Assertion",
      "value": "Assertion",
      "string": "_chai.Assertion"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "string": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "Assertion Constructor\n\nCreates object for chaining.",
      "summary": "Assertion Constructor",
      "body": "Creates object for chaining."
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 123,
    "codeStart": 131,
    "code": "function Assertion (obj, msg, stack) {\n  flag(this, 'ssfi', stack || arguments.callee);\n  flag(this, 'object', obj);\n  flag(this, 'message', msg);\n}\n\nObject.defineProperty(Assertion, 'includeStack', {\n  get: function() {\n    console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n    return config.includeStack;\n  },\n  set: function(value) {\n    console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n    config.includeStack = value;\n  }\n});\n\nObject.defineProperty(Assertion, 'showDiff', {\n  get: function() {\n    console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n    return config.showDiff;\n  },\n  set: function(value) {\n    console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n    config.showDiff = value;\n  }\n});\n\nAssertion.addProperty = function (name, fn) {\n  util.addProperty(this.prototype, name, fn);\n};\n\nAssertion.addMethod = function (name, fn) {\n  util.addMethod(this.prototype, name, fn);\n};\n\nAssertion.addChainableMethod = function (name, fn, chainingBehavior) {\n  util.addChainableMethod(this.prototype, name, fn, chainingBehavior);\n};\n\nAssertion.overwriteProperty = function (name, fn) {\n  util.overwriteProperty(this.prototype, name, fn);\n};\n\nAssertion.overwriteMethod = function (name, fn) {\n  util.overwriteMethod(this.prototype, name, fn);\n};\n\nAssertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {\n  util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);\n};",
    "ctx": {
      "type": "function",
      "name": "Assertion",
      "string": "Assertion()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "assert"
      },
      {
        "type": "param",
        "string": "{Philosophical} expression to be tested",
        "name": "expression",
        "description": "to be tested",
        "types": [
          "Philosophical"
        ],
        "typesDescription": "<a href=\"Philosophical.html\">Philosophical</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String|Function} message or function that returns message to display if expression fails",
        "name": "message",
        "description": "or function that returns message to display if expression fails",
        "types": [
          "String",
          "Function"
        ],
        "typesDescription": "<code>String</code>|<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails",
        "name": "negatedMessage",
        "description": "or function that returns negatedMessage to display if negated expression fails",
        "types": [
          "String",
          "Function"
        ],
        "typesDescription": "<code>String</code>|<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected value (remember to check for negation)",
        "name": "expected",
        "description": "value (remember to check for negation)",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} actual (optional) will default to `this.obj`",
        "name": "actual",
        "description": "(optional) will default to `this.obj`",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails",
        "name": "showDiff",
        "description": "(optional) when set to `true`, assert will display a diff in addition to the message if expression fails",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "api",
        "string": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "### .assert(expression, message, negateMessage, expected, actual, showDiff)\n\nExecutes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.",
      "summary": "### .assert(expression, message, negateMessage, expected, actual, showDiff)",
      "body": "Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass."
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 183,
    "codeStart": 198,
    "code": "Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {\n  var ok = util.test(this, arguments);\n  if (true !== showDiff) showDiff = false;\n  if (true !== config.showDiff) showDiff = false;\n\n  if (!ok) {\n    var msg = util.getMessage(this, arguments)\n      , actual = util.getActual(this, arguments);\n    throw new AssertionError(msg, {\n        actual: actual\n      , expected: expected\n      , showDiff: showDiff\n    }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "Assertion",
      "cons": "Assertion",
      "name": "assert",
      "string": "Assertion.prototype.assert()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "string": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "### ._obj\n\nQuick reference to stored `actual` value for plugin developers.",
      "summary": "### ._obj",
      "body": "Quick reference to stored `actual` value for plugin developers."
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 214,
    "codeStart": 222,
    "code": "Object.defineProperty(Assertion.prototype, '_obj',\n  { get: function () {\n      return flag(this, 'object');\n    }\n  , set: function (val) {\n      flag(this, 'object', val);\n    }\n});\n};\n\n},{\"./config\":4}],4:[function(require,module,exports){\nmodule.exports = {",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Boolean}",
        "name": "",
        "description": "",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### config.includeStack\n\nUser configurable property, influences whether stack trace\nis included in Assertion error message. Default of false\nsuppresses stack trace in the error message.\n\n    chai.config.includeStack = true;  // enable stack on error",
      "summary": "### config.includeStack",
      "body": "User configurable property, influences whether stack trace\nis included in Assertion error message. Default of false\nsuppresses stack trace in the error message.\n\n    chai.config.includeStack = true;  // enable stack on error"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 235,
    "codeStart": 248,
    "code": "includeStack: false,",
    "ctx": {
      "type": "property",
      "name": "includeStack",
      "value": "false,",
      "string": "includeStack"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Boolean}",
        "name": "",
        "description": "",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### config.showDiff\n\nUser configurable property, influences whether or not\nthe `showDiff` flag should be included in the thrown\nAssertionErrors. `false` will always be `false`; `true`\nwill be true when the assertion has requested a diff\nbe shown.",
      "summary": "### config.showDiff",
      "body": "User configurable property, influences whether or not\nthe `showDiff` flag should be included in the thrown\nAssertionErrors. `false` will always be `false`; `true`\nwill be true when the assertion has requested a diff\nbe shown."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 250,
    "codeStart": 263,
    "code": "showDiff: true,",
    "ctx": {
      "type": "property",
      "name": "showDiff",
      "value": "true,",
      "string": "showDiff"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Number}",
        "name": "",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### config.truncateThreshold\n\nUser configurable property, sets length threshold for actual and\nexpected values in assertion errors. If this threshold is exceeded, for\nexample for large data structures, the value is replaced with something\nlike `[ Array(3) ]` or `{ Object (prop1, prop2) }`.\n\nSet it to zero if you want to disable truncating altogether.\n\nThis is especially userful when doing assertions on arrays: having this\nset to a reasonable large value makes the failure messages readily\ninspectable.\n\n    chai.config.truncateThreshold = 0;  // disable truncating",
      "summary": "### config.truncateThreshold",
      "body": "User configurable property, sets length threshold for actual and\nexpected values in assertion errors. If this threshold is exceeded, for\nexample for large data structures, the value is replaced with something\nlike `[ Array(3) ]` or `{ Object (prop1, prop2) }`.\n\nSet it to zero if you want to disable truncating altogether.\n\nThis is especially userful when doing assertions on arrays: having this\nset to a reasonable large value makes the failure messages readily\ninspectable.\n\n    chai.config.truncateThreshold = 0;  // disable truncating"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 265,
    "codeStart": 285,
    "code": "truncateThreshold: 40\n\n};\n\n},{}],5:[function(require,module,exports){",
    "ctx": {
      "type": "property",
      "name": "truncateThreshold",
      "value": "40",
      "string": "truncateThreshold"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "chai\nhttp://chaijs.com\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "chai\nhttp://chaijs.com\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 290,
    "codeStart": 297,
    "code": "module.exports = function (chai, _) {\n  var Assertion = chai.Assertion\n    , toString = Object.prototype.toString\n    , flag = _.flag;",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "language chains"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### Language Chains\n\nThe following are provided as chainable getters to\nimprove the readability of your assertions. They\ndo not provide testing capabilities unless they\nhave been overwritten by a plugin.\n\n**Chains**\n\n- to\n- be\n- been\n- is\n- that\n- which\n- and\n- has\n- have\n- with\n- at\n- of\n- same",
      "summary": "### Language Chains",
      "body": "The following are provided as chainable getters to\nimprove the readability of your assertions. They\ndo not provide testing capabilities unless they\nhave been overwritten by a plugin.\n\n**Chains**\n\n- to\n- be\n- been\n- is\n- that\n- which\n- and\n- has\n- have\n- with\n- at\n- of\n- same"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 302,
    "codeStart": 331,
    "code": "[ 'to', 'be', 'been'\n, 'is', 'and', 'has', 'have'\n, 'with', 'that', 'which', 'at'\n, 'of', 'same' ].forEach(function (chain) {\n  Assertion.addProperty(chain, function () {\n    return this;\n  });\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "not"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .not\n\nNegates any of assertions following in the chain.\n\n    expect(foo).to.not.equal('bar');\n    expect(goodFn).to.not.throw(Error);\n    expect({ foo: 'baz' }).to.have.property('foo')\n      .and.not.equal('bar');",
      "summary": "### .not",
      "body": "Negates any of assertions following in the chain.\n\n    expect(foo).to.not.equal('bar');\n    expect(goodFn).to.not.throw(Error);\n    expect({ foo: 'baz' }).to.have.property('foo')\n      .and.not.equal('bar');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 340,
    "codeStart": 355,
    "code": "Assertion.addProperty('not', function () {\n  flag(this, 'negate', true);\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "deep"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .deep\n\nSets the `deep` flag, later used by the `equal` and\n`property` assertions.\n\n    expect(foo).to.deep.equal({ bar: 'baz' });\n    expect({ foo: { bar: { baz: 'quux' } } })\n      .to.have.deep.property('foo.bar.baz', 'quux');\n\n`.deep.property` special characters can be escaped\nby adding two slashes before the `.` or `[]`.\n\n    var deepCss = { '.link': { '[target]': 42 }};\n    expect(deepCss).to.have.deep.property('\\\\.link.\\\\[target\\\\]', 42);",
      "summary": "### .deep",
      "body": "Sets the `deep` flag, later used by the `equal` and\n`property` assertions.\n\n    expect(foo).to.deep.equal({ bar: 'baz' });\n    expect({ foo: { bar: { baz: 'quux' } } })\n      .to.have.deep.property('foo.bar.baz', 'quux');\n\n`.deep.property` special characters can be escaped\nby adding two slashes before the `.` or `[]`.\n\n    var deepCss = { '.link': { '[target]': 42 }};\n    expect(deepCss).to.have.deep.property('\\\\.link.\\\\[target\\\\]', 42);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 359,
    "codeStart": 380,
    "code": "Assertion.addProperty('deep', function () {\n  flag(this, 'deep', true);\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "any"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .any\n\nSets the `any` flag, (opposite of the `all` flag)\nlater used in the `keys` assertion.\n\n    expect(foo).to.have.any.keys('bar', 'baz');",
      "summary": "### .any",
      "body": "Sets the `any` flag, (opposite of the `all` flag)\nlater used in the `keys` assertion.\n\n    expect(foo).to.have.any.keys('bar', 'baz');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 384,
    "codeStart": 397,
    "code": "Assertion.addProperty('any', function () {\n  flag(this, 'any', true);\n  flag(this, 'all', false)\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "all"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .all\n\nSets the `all` flag (opposite of the `any` flag)\nlater used by the `keys` assertion.\n\n    expect(foo).to.have.all.keys('bar', 'baz');",
      "summary": "### .all",
      "body": "Sets the `all` flag (opposite of the `any` flag)\nlater used by the `keys` assertion.\n\n    expect(foo).to.have.all.keys('bar', 'baz');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 403,
    "codeStart": 416,
    "code": "Assertion.addProperty('all', function () {\n  flag(this, 'all', true);\n  flag(this, 'any', false);\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "a"
      },
      {
        "type": "alias",
        "string": "an"
      },
      {
        "type": "param",
        "string": "{String} type",
        "name": "type",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .a(type)\n\nThe `a` and `an` assertions are aliases that can be\nused either as language chains or to assert a value's\ntype.\n\n    // typeof\n    expect('test').to.be.a('string');\n    expect({ foo: 'bar' }).to.be.an('object');\n    expect(null).to.be.a('null');\n    expect(undefined).to.be.an('undefined');\n    expect(new Error).to.be.an('error');\n    expect(new Promise).to.be.a('promise');\n    expect(new Float32Array()).to.be.a('float32array');\n    expect(Symbol()).to.be.a('symbol');\n\n    // es6 overrides\n    expect({[Symbol.toStringTag]:()=>'foo'}).to.be.a('foo');\n\n    // language chain\n    expect(foo).to.be.an.instanceof(Foo);",
      "summary": "### .a(type)",
      "body": "The `a` and `an` assertions are aliases that can be\nused either as language chains or to assert a value's\ntype.\n\n    // typeof\n    expect('test').to.be.a('string');\n    expect({ foo: 'bar' }).to.be.an('object');\n    expect(null).to.be.a('null');\n    expect(undefined).to.be.an('undefined');\n    expect(new Error).to.be.an('error');\n    expect(new Promise).to.be.a('promise');\n    expect(new Float32Array()).to.be.a('float32array');\n    expect(Symbol()).to.be.a('symbol');\n\n    // es6 overrides\n    expect({[Symbol.toStringTag]:()=>'foo'}).to.be.a('foo');\n\n    // language chain\n    expect(foo).to.be.an.instanceof(Foo);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 421,
    "codeStart": 452,
    "code": "function an (type, msg) {\n  if (msg) flag(this, 'message', msg);\n  type = type.toLowerCase();\n  var obj = flag(this, 'object')\n    , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';\n\n  this.assert(\n      type === _.type(obj)\n    , 'expected #{this} to be ' + article + type\n    , 'expected #{this} not to be ' + article + type\n  );\n}\n\nAssertion.addChainableMethod('an', an);\nAssertion.addChainableMethod('a', an);",
    "ctx": {
      "type": "function",
      "name": "an",
      "string": "an()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "include"
      },
      {
        "type": "alias",
        "string": "contain"
      },
      {
        "type": "alias",
        "string": "includes"
      },
      {
        "type": "alias",
        "string": "contains"
      },
      {
        "type": "param",
        "string": "{Object|String|Number} obj",
        "name": "obj",
        "description": "",
        "types": [
          "Object",
          "String",
          "Number"
        ],
        "typesDescription": "<code>Object</code>|<code>String</code>|<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .include(value)\n\nThe `include` and `contain` assertions can be used as either property\nbased language chains or as methods to assert the inclusion of an object\nin an array or a substring in a string. When used as language chains,\nthey toggle the `contains` flag for the `keys` assertion.\n\n    expect([1,2,3]).to.include(2);\n    expect('foobar').to.contain('foo');\n    expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');",
      "summary": "### .include(value)",
      "body": "The `include` and `contain` assertions can be used as either property\nbased language chains or as methods to assert the inclusion of an object\nin an array or a substring in a string. When used as language chains,\nthey toggle the `contains` flag for the `keys` assertion.\n\n    expect([1,2,3]).to.include(2);\n    expect('foobar').to.contain('foo');\n    expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 468,
    "codeStart": 490,
    "code": "function includeChainingBehavior () {\n  flag(this, 'contains', true);\n}\n\nfunction include (val, msg) {\n  _.expectTypes(this, ['array', 'object', 'string']);\n\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object');\n  var expected = false;\n\n  if (_.type(obj) === 'array' && _.type(val) === 'object') {\n    for (var i in obj) {\n      if (_.eql(obj[i], val)) {\n        expected = true;\n        break;\n      }\n    }\n  } else if (_.type(val) === 'object') {\n    if (!flag(this, 'negate')) {\n      for (var k in val) new Assertion(obj).property(k, val[k]);\n      return;\n    }\n    var subset = {};\n    for (var k in val) subset[k] = obj[k];\n    expected = _.eql(subset, val);\n  } else {\n    expected = (obj != undefined) && ~obj.indexOf(val);\n  }\n  this.assert(\n      expected\n    , 'expected #{this} to include ' + _.inspect(val)\n    , 'expected #{this} to not include ' + _.inspect(val));\n}\n\nAssertion.addChainableMethod('include', include, includeChainingBehavior);\nAssertion.addChainableMethod('contain', include, includeChainingBehavior);\nAssertion.addChainableMethod('contains', include, includeChainingBehavior);\nAssertion.addChainableMethod('includes', include, includeChainingBehavior);",
    "ctx": {
      "type": "function",
      "name": "includeChainingBehavior",
      "string": "includeChainingBehavior()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "ok"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .ok\n\nAsserts that the target is truthy.\n\n    expect('everything').to.be.ok;\n    expect(1).to.be.ok;\n    expect(false).to.not.be.ok;\n    expect(undefined).to.not.be.ok;\n    expect(null).to.not.be.ok;",
      "summary": "### .ok",
      "body": "Asserts that the target is truthy.\n\n    expect('everything').to.be.ok;\n    expect(1).to.be.ok;\n    expect(false).to.not.be.ok;\n    expect(undefined).to.not.be.ok;\n    expect(null).to.not.be.ok;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 530,
    "codeStart": 546,
    "code": "Assertion.addProperty('ok', function () {\n  this.assert(\n      flag(this, 'object')\n    , 'expected #{this} to be truthy'\n    , 'expected #{this} to be falsy');\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "true"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .true\n\nAsserts that the target is `true`.\n\n    expect(true).to.be.true;\n    expect(1).to.not.be.true;",
      "summary": "### .true",
      "body": "Asserts that the target is `true`.\n\n    expect(true).to.be.true;\n    expect(1).to.not.be.true;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 553,
    "codeStart": 566,
    "code": "Assertion.addProperty('true', function () {\n  this.assert(\n      true === flag(this, 'object')\n    , 'expected #{this} to be true'\n    , 'expected #{this} to be false'\n    , this.negate ? false : true\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "false"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .false\n\nAsserts that the target is `false`.\n\n    expect(false).to.be.false;\n    expect(0).to.not.be.false;",
      "summary": "### .false",
      "body": "Asserts that the target is `false`.\n\n    expect(false).to.be.false;\n    expect(0).to.not.be.false;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 575,
    "codeStart": 588,
    "code": "Assertion.addProperty('false', function () {\n  this.assert(\n      false === flag(this, 'object')\n    , 'expected #{this} to be false'\n    , 'expected #{this} to be true'\n    , this.negate ? true : false\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "null"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .null\n\nAsserts that the target is `null`.\n\n    expect(null).to.be.null;\n    expect(undefined).to.not.be.null;",
      "summary": "### .null",
      "body": "Asserts that the target is `null`.\n\n    expect(null).to.be.null;\n    expect(undefined).to.not.be.null;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 597,
    "codeStart": 610,
    "code": "Assertion.addProperty('null', function () {\n  this.assert(\n      null === flag(this, 'object')\n    , 'expected #{this} to be null'\n    , 'expected #{this} not to be null'\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "undefined"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .undefined\n\nAsserts that the target is `undefined`.\n\n    expect(undefined).to.be.undefined;\n    expect(null).to.not.be.undefined;",
      "summary": "### .undefined",
      "body": "Asserts that the target is `undefined`.\n\n    expect(undefined).to.be.undefined;\n    expect(null).to.not.be.undefined;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 618,
    "codeStart": 631,
    "code": "Assertion.addProperty('undefined', function () {\n  this.assert(\n      undefined === flag(this, 'object')\n    , 'expected #{this} to be undefined'\n    , 'expected #{this} not to be undefined'\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "NaN"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .NaN\nAsserts that the target is `NaN`.\n\n    expect('foo').to.be.NaN;\n    expect(4).not.to.be.NaN;",
      "summary": "### .NaN\nAsserts that the target is `NaN`.",
      "body": "    expect('foo').to.be.NaN;\n    expect(4).not.to.be.NaN;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 639,
    "codeStart": 651,
    "code": "Assertion.addProperty('NaN', function () {\n  this.assert(\n      isNaN(flag(this, 'object'))\n      , 'expected #{this} to be NaN'\n      , 'expected #{this} not to be NaN'\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "exist"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .exist\n\nAsserts that the target is neither `null` nor `undefined`.\n\n    var foo = 'hi'\n      , bar = null\n      , baz;\n\n    expect(foo).to.exist;\n    expect(bar).to.not.exist;\n    expect(baz).to.not.exist;",
      "summary": "### .exist",
      "body": "Asserts that the target is neither `null` nor `undefined`.\n\n    var foo = 'hi'\n      , bar = null\n      , baz;\n\n    expect(foo).to.exist;\n    expect(bar).to.not.exist;\n    expect(baz).to.not.exist;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 659,
    "codeStart": 677,
    "code": "Assertion.addProperty('exist', function () {\n  this.assert(\n      null != flag(this, 'object')\n    , 'expected #{this} to exist'\n    , 'expected #{this} to not exist'\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "empty"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .empty\n\nAsserts that the target's length is `0`. For arrays and strings, it checks\nthe `length` property. For objects, it gets the count of\nenumerable keys.\n\n    expect([]).to.be.empty;\n    expect('').to.be.empty;\n    expect({}).to.be.empty;",
      "summary": "### .empty",
      "body": "Asserts that the target's length is `0`. For arrays and strings, it checks\nthe `length` property. For objects, it gets the count of\nenumerable keys.\n\n    expect([]).to.be.empty;\n    expect('').to.be.empty;\n    expect({}).to.be.empty;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 686,
    "codeStart": 702,
    "code": "Assertion.addProperty('empty', function () {\n  var obj = flag(this, 'object')\n    , expected = obj;\n\n  if (Array.isArray(obj) || 'string' === typeof object) {\n    expected = obj.length;\n  } else if (typeof obj === 'object') {\n    expected = Object.keys(obj).length;\n  }\n\n  this.assert(\n      !expected\n    , 'expected #{this} to be empty'\n    , 'expected #{this} not to be empty'\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "arguments"
      },
      {
        "type": "alias",
        "string": "Arguments"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .arguments\n\nAsserts that the target is an arguments object.\n\n    function test () {\n      expect(arguments).to.be.arguments;\n    }",
      "summary": "### .arguments",
      "body": "Asserts that the target is an arguments object.\n\n    function test () {\n      expect(arguments).to.be.arguments;\n    }"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 719,
    "codeStart": 734,
    "code": "function checkArguments () {\n  var obj = flag(this, 'object')\n    , type = Object.prototype.toString.call(obj);\n  this.assert(\n      '[object Arguments]' === type\n    , 'expected #{this} to be arguments but got ' + type\n    , 'expected #{this} to not be arguments'\n  );\n}\n\nAssertion.addProperty('arguments', checkArguments);\nAssertion.addProperty('Arguments', checkArguments);",
    "ctx": {
      "type": "function",
      "name": "checkArguments",
      "string": "checkArguments()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "equal"
      },
      {
        "type": "alias",
        "string": "equals"
      },
      {
        "type": "alias",
        "string": "eq"
      },
      {
        "type": "alias",
        "string": "deep.equal"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .equal(value)\n\nAsserts that the target is strictly equal (`===`) to `value`.\nAlternately, if the `deep` flag is set, asserts that\nthe target is deeply equal to `value`.\n\n    expect('hello').to.equal('hello');\n    expect(42).to.equal(42);\n    expect(1).to.not.equal(true);\n    expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });\n    expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });",
      "summary": "### .equal(value)",
      "body": "Asserts that the target is strictly equal (`===`) to `value`.\nAlternately, if the `deep` flag is set, asserts that\nthe target is deeply equal to `value`.\n\n    expect('hello').to.equal('hello');\n    expect(42).to.equal(42);\n    expect(1).to.not.equal(true);\n    expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });\n    expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 747,
    "codeStart": 770,
    "code": "function assertEqual (val, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object');\n  if (flag(this, 'deep')) {\n    return this.eql(val);\n  } else {\n    this.assert(\n        val === obj\n      , 'expected #{this} to equal #{exp}'\n      , 'expected #{this} to not equal #{exp}'\n      , val\n      , this._obj\n      , true\n    );\n  }\n}\n\nAssertion.addMethod('equal', assertEqual);\nAssertion.addMethod('equals', assertEqual);\nAssertion.addMethod('eq', assertEqual);",
    "ctx": {
      "type": "function",
      "name": "assertEqual",
      "string": "assertEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "eql"
      },
      {
        "type": "alias",
        "string": "eqls"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .eql(value)\n\nAsserts that the target is deeply equal to `value`.\n\n    expect({ foo: 'bar' }).to.eql({ foo: 'bar' });\n    expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);",
      "summary": "### .eql(value)",
      "body": "Asserts that the target is deeply equal to `value`.\n\n    expect({ foo: 'bar' }).to.eql({ foo: 'bar' });\n    expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 791,
    "codeStart": 807,
    "code": "function assertEql(obj, msg) {\n  if (msg) flag(this, 'message', msg);\n  this.assert(\n      _.eql(obj, flag(this, 'object'))\n    , 'expected #{this} to deeply equal #{exp}'\n    , 'expected #{this} to not deeply equal #{exp}'\n    , obj\n    , this._obj\n    , true\n  );\n}\n\nAssertion.addMethod('eql', assertEql);\nAssertion.addMethod('eqls', assertEql);",
    "ctx": {
      "type": "function",
      "name": "assertEql",
      "string": "assertEql()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "above"
      },
      {
        "type": "alias",
        "string": "gt"
      },
      {
        "type": "alias",
        "string": "greaterThan"
      },
      {
        "type": "param",
        "string": "{Number} value",
        "name": "value",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .above(value)\n\nAsserts that the target is greater than `value`.\n\n    expect(10).to.be.above(5);\n\nCan also be used in conjunction with `length` to\nassert a minimum length. The benefit being a\nmore informative error message than if the length\nwas supplied directly.\n\n    expect('foo').to.have.length.above(2);\n    expect([ 1, 2, 3 ]).to.have.length.above(2);",
      "summary": "### .above(value)",
      "body": "Asserts that the target is greater than `value`.\n\n    expect(10).to.be.above(5);\n\nCan also be used in conjunction with `length` to\nassert a minimum length. The benefit being a\nmore informative error message than if the length\nwas supplied directly.\n\n    expect('foo').to.have.length.above(2);\n    expect([ 1, 2, 3 ]).to.have.length.above(2);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 822,
    "codeStart": 846,
    "code": "function assertAbove (n, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object');\n  if (flag(this, 'doLength')) {\n    new Assertion(obj, msg).to.have.property('length');\n    var len = obj.length;\n    this.assert(\n        len > n\n      , 'expected #{this} to have a length above #{exp} but got #{act}'\n      , 'expected #{this} to not have a length above #{exp}'\n      , n\n      , len\n    );\n  } else {\n    this.assert(\n        obj > n\n      , 'expected #{this} to be above ' + n\n      , 'expected #{this} to be at most ' + n\n    );\n  }\n}\n\nAssertion.addMethod('above', assertAbove);\nAssertion.addMethod('gt', assertAbove);\nAssertion.addMethod('greaterThan', assertAbove);",
    "ctx": {
      "type": "function",
      "name": "assertAbove",
      "string": "assertAbove()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "least"
      },
      {
        "type": "alias",
        "string": "gte"
      },
      {
        "type": "param",
        "string": "{Number} value",
        "name": "value",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .least(value)\n\nAsserts that the target is greater than or equal to `value`.\n\n    expect(10).to.be.at.least(10);\n\nCan also be used in conjunction with `length` to\nassert a minimum length. The benefit being a\nmore informative error message than if the length\nwas supplied directly.\n\n    expect('foo').to.have.length.of.at.least(2);\n    expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);",
      "summary": "### .least(value)",
      "body": "Asserts that the target is greater than or equal to `value`.\n\n    expect(10).to.be.at.least(10);\n\nCan also be used in conjunction with `length` to\nassert a minimum length. The benefit being a\nmore informative error message than if the length\nwas supplied directly.\n\n    expect('foo').to.have.length.of.at.least(2);\n    expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 872,
    "codeStart": 895,
    "code": "function assertLeast (n, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object');\n  if (flag(this, 'doLength')) {\n    new Assertion(obj, msg).to.have.property('length');\n    var len = obj.length;\n    this.assert(\n        len >= n\n      , 'expected #{this} to have a length at least #{exp} but got #{act}'\n      , 'expected #{this} to have a length below #{exp}'\n      , n\n      , len\n    );\n  } else {\n    this.assert(\n        obj >= n\n      , 'expected #{this} to be at least ' + n\n      , 'expected #{this} to be below ' + n\n    );\n  }\n}\n\nAssertion.addMethod('least', assertLeast);\nAssertion.addMethod('gte', assertLeast);",
    "ctx": {
      "type": "function",
      "name": "assertLeast",
      "string": "assertLeast()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "below"
      },
      {
        "type": "alias",
        "string": "lt"
      },
      {
        "type": "alias",
        "string": "lessThan"
      },
      {
        "type": "param",
        "string": "{Number} value",
        "name": "value",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .below(value)\n\nAsserts that the target is less than `value`.\n\n    expect(5).to.be.below(10);\n\nCan also be used in conjunction with `length` to\nassert a maximum length. The benefit being a\nmore informative error message than if the length\nwas supplied directly.\n\n    expect('foo').to.have.length.below(4);\n    expect([ 1, 2, 3 ]).to.have.length.below(4);",
      "summary": "### .below(value)",
      "body": "Asserts that the target is less than `value`.\n\n    expect(5).to.be.below(10);\n\nCan also be used in conjunction with `length` to\nassert a maximum length. The benefit being a\nmore informative error message than if the length\nwas supplied directly.\n\n    expect('foo').to.have.length.below(4);\n    expect([ 1, 2, 3 ]).to.have.length.below(4);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 920,
    "codeStart": 944,
    "code": "function assertBelow (n, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object');\n  if (flag(this, 'doLength')) {\n    new Assertion(obj, msg).to.have.property('length');\n    var len = obj.length;\n    this.assert(\n        len < n\n      , 'expected #{this} to have a length below #{exp} but got #{act}'\n      , 'expected #{this} to not have a length below #{exp}'\n      , n\n      , len\n    );\n  } else {\n    this.assert(\n        obj < n\n      , 'expected #{this} to be below ' + n\n      , 'expected #{this} to be at least ' + n\n    );\n  }\n}\n\nAssertion.addMethod('below', assertBelow);\nAssertion.addMethod('lt', assertBelow);\nAssertion.addMethod('lessThan', assertBelow);",
    "ctx": {
      "type": "function",
      "name": "assertBelow",
      "string": "assertBelow()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "most"
      },
      {
        "type": "alias",
        "string": "lte"
      },
      {
        "type": "param",
        "string": "{Number} value",
        "name": "value",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .most(value)\n\nAsserts that the target is less than or equal to `value`.\n\n    expect(5).to.be.at.most(5);\n\nCan also be used in conjunction with `length` to\nassert a maximum length. The benefit being a\nmore informative error message than if the length\nwas supplied directly.\n\n    expect('foo').to.have.length.of.at.most(4);\n    expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);",
      "summary": "### .most(value)",
      "body": "Asserts that the target is less than or equal to `value`.\n\n    expect(5).to.be.at.most(5);\n\nCan also be used in conjunction with `length` to\nassert a maximum length. The benefit being a\nmore informative error message than if the length\nwas supplied directly.\n\n    expect('foo').to.have.length.of.at.most(4);\n    expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 970,
    "codeStart": 993,
    "code": "function assertMost (n, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object');\n  if (flag(this, 'doLength')) {\n    new Assertion(obj, msg).to.have.property('length');\n    var len = obj.length;\n    this.assert(\n        len <= n\n      , 'expected #{this} to have a length at most #{exp} but got #{act}'\n      , 'expected #{this} to have a length above #{exp}'\n      , n\n      , len\n    );\n  } else {\n    this.assert(\n        obj <= n\n      , 'expected #{this} to be at most ' + n\n      , 'expected #{this} to be above ' + n\n    );\n  }\n}\n\nAssertion.addMethod('most', assertMost);\nAssertion.addMethod('lte', assertMost);",
    "ctx": {
      "type": "function",
      "name": "assertMost",
      "string": "assertMost()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "within"
      },
      {
        "type": "param",
        "string": "{Number} start lowerbound inclusive",
        "name": "start",
        "description": "lowerbound inclusive",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} finish upperbound inclusive",
        "name": "finish",
        "description": "upperbound inclusive",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .within(start, finish)\n\nAsserts that the target is within a range.\n\n    expect(7).to.be.within(5,10);\n\nCan also be used in conjunction with `length` to\nassert a length range. The benefit being a\nmore informative error message than if the length\nwas supplied directly.\n\n    expect('foo').to.have.length.within(2,4);\n    expect([ 1, 2, 3 ]).to.have.length.within(2,4);",
      "summary": "### .within(start, finish)",
      "body": "Asserts that the target is within a range.\n\n    expect(7).to.be.within(5,10);\n\nCan also be used in conjunction with `length` to\nassert a length range. The benefit being a\nmore informative error message than if the length\nwas supplied directly.\n\n    expect('foo').to.have.length.within(2,4);\n    expect([ 1, 2, 3 ]).to.have.length.within(2,4);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1018,
    "codeStart": 1041,
    "code": "Assertion.addMethod('within', function (start, finish, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object')\n    , range = start + '..' + finish;\n  if (flag(this, 'doLength')) {\n    new Assertion(obj, msg).to.have.property('length');\n    var len = obj.length;\n    this.assert(\n        len >= start && len <= finish\n      , 'expected #{this} to have a length within ' + range\n      , 'expected #{this} to not have a length within ' + range\n    );\n  } else {\n    this.assert(\n        obj >= start && obj <= finish\n      , 'expected #{this} to be within ' + range\n      , 'expected #{this} to not be within ' + range\n    );\n  }\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "instanceof"
      },
      {
        "type": "param",
        "string": "{Constructor} constructor",
        "name": "constructor",
        "description": "",
        "types": [
          "Constructor"
        ],
        "typesDescription": "<a href=\"Constructor.html\">Constructor</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "alias",
        "string": "instanceOf"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .instanceof(constructor)\n\nAsserts that the target is an instance of `constructor`.\n\n    var Tea = function (name) { this.name = name; }\n      , Chai = new Tea('chai');\n\n    expect(Chai).to.be.an.instanceof(Tea);\n    expect([ 1, 2, 3 ]).to.be.instanceof(Array);",
      "summary": "### .instanceof(constructor)",
      "body": "Asserts that the target is an instance of `constructor`.\n\n    var Tea = function (name) { this.name = name; }\n      , Chai = new Tea('chai');\n\n    expect(Chai).to.be.an.instanceof(Tea);\n    expect([ 1, 2, 3 ]).to.be.instanceof(Array);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1062,
    "codeStart": 1081,
    "code": "function assertInstanceOf (constructor, msg) {\n  if (msg) flag(this, 'message', msg);\n  var name = _.getName(constructor);\n  this.assert(\n      flag(this, 'object') instanceof constructor\n    , 'expected #{this} to be an instance of ' + name\n    , 'expected #{this} to not be an instance of ' + name\n  );\n};\n\nAssertion.addMethod('instanceof', assertInstanceOf);\nAssertion.addMethod('instanceOf', assertInstanceOf);",
    "ctx": {
      "type": "function",
      "name": "assertInstanceOf",
      "string": "assertInstanceOf()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "property"
      },
      {
        "type": "alias",
        "string": "deep.property"
      },
      {
        "type": "param",
        "string": "{String} name",
        "name": "name",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} value (optional)",
        "name": "value",
        "description": "(optional)",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "value of property for chaining",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "value of property for chaining"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .property(name, [value])\n\nAsserts that the target has a property `name`, optionally asserting that\nthe value of that property is strictly equal to  `value`.\nIf the `deep` flag is set, you can use dot- and bracket-notation for deep\nreferences into objects and arrays.\n\n    // simple referencing\n    var obj = { foo: 'bar' };\n    expect(obj).to.have.property('foo');\n    expect(obj).to.have.property('foo', 'bar');\n\n    // deep referencing\n    var deepObj = {\n        green: { tea: 'matcha' }\n      , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]\n    };\n\n    expect(deepObj).to.have.deep.property('green.tea', 'matcha');\n    expect(deepObj).to.have.deep.property('teas[1]', 'matcha');\n    expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');\n\nYou can also use an array as the starting point of a `deep.property`\nassertion, or traverse nested arrays.\n\n    var arr = [\n        [ 'chai', 'matcha', 'konacha' ]\n      , [ { tea: 'chai' }\n        , { tea: 'matcha' }\n        , { tea: 'konacha' } ]\n    ];\n\n    expect(arr).to.have.deep.property('[0][1]', 'matcha');\n    expect(arr).to.have.deep.property('[1][2].tea', 'konacha');\n\nFurthermore, `property` changes the subject of the assertion\nto be the value of that property from the original object. This\npermits for further chainable assertions on that property.\n\n    expect(obj).to.have.property('foo')\n      .that.is.a('string');\n    expect(deepObj).to.have.property('green')\n      .that.is.an('object')\n      .that.deep.equals({ tea: 'matcha' });\n    expect(deepObj).to.have.property('teas')\n      .that.is.an('array')\n      .with.deep.property('[2]')\n        .that.deep.equals({ tea: 'konacha' });\n\nNote that dots and bracket in `name` must be backslash-escaped when\nthe `deep` flag is set, while they must NOT be escaped when the `deep`\nflag is not set.\n\n    // simple referencing\n    var css = { '.link[target]': 42 };\n    expect(css).to.have.property('.link[target]', 42);\n\n    // deep referencing\n    var deepCss = { '.link': { '[target]': 42 }};\n    expect(deepCss).to.have.deep.property('\\\\.link.\\\\[target\\\\]', 42);",
      "summary": "### .property(name, [value])",
      "body": "Asserts that the target has a property `name`, optionally asserting that\nthe value of that property is strictly equal to  `value`.\nIf the `deep` flag is set, you can use dot- and bracket-notation for deep\nreferences into objects and arrays.\n\n    // simple referencing\n    var obj = { foo: 'bar' };\n    expect(obj).to.have.property('foo');\n    expect(obj).to.have.property('foo', 'bar');\n\n    // deep referencing\n    var deepObj = {\n        green: { tea: 'matcha' }\n      , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]\n    };\n\n    expect(deepObj).to.have.deep.property('green.tea', 'matcha');\n    expect(deepObj).to.have.deep.property('teas[1]', 'matcha');\n    expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');\n\nYou can also use an array as the starting point of a `deep.property`\nassertion, or traverse nested arrays.\n\n    var arr = [\n        [ 'chai', 'matcha', 'konacha' ]\n      , [ { tea: 'chai' }\n        , { tea: 'matcha' }\n        , { tea: 'konacha' } ]\n    ];\n\n    expect(arr).to.have.deep.property('[0][1]', 'matcha');\n    expect(arr).to.have.deep.property('[1][2].tea', 'konacha');\n\nFurthermore, `property` changes the subject of the assertion\nto be the value of that property from the original object. This\npermits for further chainable assertions on that property.\n\n    expect(obj).to.have.property('foo')\n      .that.is.a('string');\n    expect(deepObj).to.have.property('green')\n      .that.is.an('object')\n      .that.deep.equals({ tea: 'matcha' });\n    expect(deepObj).to.have.property('teas')\n      .that.is.an('array')\n      .with.deep.property('[2]')\n        .that.deep.equals({ tea: 'konacha' });\n\nNote that dots and bracket in `name` must be backslash-escaped when\nthe `deep` flag is set, while they must NOT be escaped when the `deep`\nflag is not set.\n\n    // simple referencing\n    var css = { '.link[target]': 42 };\n    expect(css).to.have.property('.link[target]', 42);\n\n    // deep referencing\n    var deepCss = { '.link': { '[target]': 42 }};\n    expect(deepCss).to.have.deep.property('\\\\.link.\\\\[target\\\\]', 42);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1094,
    "codeStart": 1166,
    "code": "Assertion.addMethod('property', function (name, val, msg) {\n  if (msg) flag(this, 'message', msg);\n\n  var isDeep = !!flag(this, 'deep')\n    , descriptor = isDeep ? 'deep property ' : 'property '\n    , negate = flag(this, 'negate')\n    , obj = flag(this, 'object')\n    , pathInfo = isDeep ? _.getPathInfo(name, obj) : null\n    , hasProperty = isDeep\n      ? pathInfo.exists\n      : _.hasProperty(name, obj)\n    , value = isDeep\n      ? pathInfo.value\n      : obj[name];\n\n  if (negate && arguments.length > 1) {\n    if (undefined === value) {\n      msg = (msg != null) ? msg + ': ' : '';\n      throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));\n    }\n  } else {\n    this.assert(\n        hasProperty\n      , 'expected #{this} to have a ' + descriptor + _.inspect(name)\n      , 'expected #{this} to not have ' + descriptor + _.inspect(name));\n  }\n\n  if (arguments.length > 1) {\n    this.assert(\n        val === value\n      , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'\n      , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'\n      , val\n      , value\n    );\n  }\n\n  flag(this, 'object', value);\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "ownProperty"
      },
      {
        "type": "alias",
        "string": "haveOwnProperty"
      },
      {
        "type": "param",
        "string": "{String} name",
        "name": "name",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .ownProperty(name)\n\nAsserts that the target has an own property `name`.\n\n    expect('test').to.have.ownProperty('length');",
      "summary": "### .ownProperty(name)",
      "body": "Asserts that the target has an own property `name`.\n\n    expect('test').to.have.ownProperty('length');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1207,
    "codeStart": 1222,
    "code": "function assertOwnProperty (name, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object');\n  this.assert(\n      obj.hasOwnProperty(name)\n    , 'expected #{this} to have own property ' + _.inspect(name)\n    , 'expected #{this} to not have own property ' + _.inspect(name)\n  );\n}\n\nAssertion.addMethod('ownProperty', assertOwnProperty);\nAssertion.addMethod('haveOwnProperty', assertOwnProperty);",
    "ctx": {
      "type": "function",
      "name": "assertOwnProperty",
      "string": "assertOwnProperty()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "ownPropertyDescriptor"
      },
      {
        "type": "alias",
        "string": "haveOwnPropertyDescriptor"
      },
      {
        "type": "param",
        "string": "{String} name",
        "name": "name",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} descriptor _optional_",
        "name": "descriptor",
        "description": "_optional_",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .ownPropertyDescriptor(name[, descriptor[, message]])\n\nAsserts that the target has an own property descriptor `name`, that optionally matches `descriptor`.\n\n    expect('test').to.have.ownPropertyDescriptor('length');\n    expect('test').to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 4 });\n    expect('test').not.to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 3 });\n    expect('test').ownPropertyDescriptor('length').to.have.property('enumerable', false);\n    expect('test').ownPropertyDescriptor('length').to.have.keys('value');",
      "summary": "### .ownPropertyDescriptor(name[, descriptor[, message]])",
      "body": "Asserts that the target has an own property descriptor `name`, that optionally matches `descriptor`.\n\n    expect('test').to.have.ownPropertyDescriptor('length');\n    expect('test').to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 4 });\n    expect('test').not.to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 3 });\n    expect('test').ownPropertyDescriptor('length').to.have.property('enumerable', false);\n    expect('test').ownPropertyDescriptor('length').to.have.keys('value');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1235,
    "codeStart": 1255,
    "code": "function assertOwnPropertyDescriptor (name, descriptor, msg) {\n  if (typeof descriptor === 'string') {\n    msg = descriptor;\n    descriptor = null;\n  }\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object');\n  var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);\n  if (actualDescriptor && descriptor) {\n    this.assert(\n        _.eql(descriptor, actualDescriptor)\n      , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor)\n      , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor)\n      , descriptor\n      , actualDescriptor\n      , true\n    );\n  } else {\n    this.assert(\n        actualDescriptor\n      , 'expected #{this} to have an own property descriptor for ' + _.inspect(name)\n      , 'expected #{this} to not have an own property descriptor for ' + _.inspect(name)\n    );\n  }\n  flag(this, 'object', actualDescriptor);\n}\n\nAssertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);\nAssertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);",
    "ctx": {
      "type": "function",
      "name": "assertOwnPropertyDescriptor",
      "string": "assertOwnPropertyDescriptor()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "length"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .length\n\nSets the `doLength` flag later used as a chain precursor to a value\ncomparison for the `length` property.\n\n    expect('foo').to.have.length.above(2);\n    expect([ 1, 2, 3 ]).to.have.length.above(2);\n    expect('foo').to.have.length.below(4);\n    expect([ 1, 2, 3 ]).to.have.length.below(4);\n    expect('foo').to.have.length.within(2,4);\n    expect([ 1, 2, 3 ]).to.have.length.within(2,4);\n\n*Deprecation notice:* Using `length` as an assertion will be deprecated\nin version 2.4.0 and removed in 3.0.0. Code using the old style of\nasserting for `length` property value using `length(value)` should be\nswitched to use `lengthOf(value)` instead.",
      "summary": "### .length",
      "body": "Sets the `doLength` flag later used as a chain precursor to a value\ncomparison for the `length` property.\n\n    expect('foo').to.have.length.above(2);\n    expect([ 1, 2, 3 ]).to.have.length.above(2);\n    expect('foo').to.have.length.below(4);\n    expect([ 1, 2, 3 ]).to.have.length.below(4);\n    expect('foo').to.have.length.within(2,4);\n    expect([ 1, 2, 3 ]).to.have.length.within(2,4);\n\n*Deprecation notice:* Using `length` as an assertion will be deprecated\nin version 2.4.0 and removed in 3.0.0. Code using the old style of\nasserting for `length` property value using `length(value)` should be\nswitched to use `lengthOf(value)` instead."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1285,
    "codeStart": 1307
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "lengthOf"
      },
      {
        "type": "param",
        "string": "{Number} length",
        "name": "length",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .lengthOf(value[, message])\n\nAsserts that the target's `length` property has\nthe expected value.\n\n    expect([ 1, 2, 3]).to.have.lengthOf(3);\n    expect('foobar').to.have.lengthOf(6);",
      "summary": "### .lengthOf(value[, message])",
      "body": "Asserts that the target's `length` property has\nthe expected value.\n\n    expect([ 1, 2, 3]).to.have.lengthOf(3);\n    expect('foobar').to.have.lengthOf(6);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1308,
    "codeStart": 1324,
    "code": "function assertLengthChain () {\n  flag(this, 'doLength', true);\n}\n\nfunction assertLength (n, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object');\n  new Assertion(obj, msg).to.have.property('length');\n  var len = obj.length;\n\n  this.assert(\n      len == n\n    , 'expected #{this} to have a length of #{exp} but got #{act}'\n    , 'expected #{this} to not have a length of #{act}'\n    , n\n    , len\n  );\n}\n\nAssertion.addChainableMethod('length', assertLength, assertLengthChain);\nAssertion.addMethod('lengthOf', assertLength);",
    "ctx": {
      "type": "function",
      "name": "assertLengthChain",
      "string": "assertLengthChain()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "match"
      },
      {
        "type": "alias",
        "string": "matches"
      },
      {
        "type": "param",
        "string": "{RegExp} RegularExpression",
        "name": "RegularExpression",
        "description": "",
        "types": [
          "RegExp"
        ],
        "typesDescription": "<code>RegExp</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .match(regexp)\n\nAsserts that the target matches a regular expression.\n\n    expect('foobar').to.match(/^foo/);",
      "summary": "### .match(regexp)",
      "body": "Asserts that the target matches a regular expression.\n\n    expect('foobar').to.match(/^foo/);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1346,
    "codeStart": 1360,
    "code": "function assertMatch(re, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object');\n  this.assert(\n      re.exec(obj)\n    , 'expected #{this} to match ' + re\n    , 'expected #{this} not to match ' + re\n  );\n}\n\nAssertion.addMethod('match', assertMatch);\nAssertion.addMethod('matches', assertMatch);",
    "ctx": {
      "type": "function",
      "name": "assertMatch",
      "string": "assertMatch()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "string"
      },
      {
        "type": "param",
        "string": "{String} string",
        "name": "string",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .string(string)\n\nAsserts that the string target contains another string.\n\n    expect('foobar').to.have.string('bar');",
      "summary": "### .string(string)",
      "body": "Asserts that the string target contains another string.\n\n    expect('foobar').to.have.string('bar');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1373,
    "codeStart": 1387,
    "code": "Assertion.addMethod('string', function (str, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object');\n  new Assertion(obj, msg).is.a('string');\n\n  this.assert(\n      ~obj.indexOf(str)\n    , 'expected #{this} to contain ' + _.inspect(str)\n    , 'expected #{this} to not contain ' + _.inspect(str)\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "keys"
      },
      {
        "type": "alias",
        "string": "key"
      },
      {
        "type": "param",
        "string": "{...String|Array|Object} keys",
        "name": "keys",
        "description": "",
        "types": [
          "String",
          "Array",
          "Object"
        ],
        "typesDescription": "...<code>String</code>|<code>Array</code>|<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": true
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .keys(key1, [key2], [...])\n\nAsserts that the target contains any or all of the passed-in keys.\nUse in combination with `any`, `all`, `contains`, or `have` will affect\nwhat will pass.\n\nWhen used in conjunction with `any`, at least one key that is passed\nin must exist in the target object. This is regardless whether or not\nthe `have` or `contain` qualifiers are used. Note, either `any` or `all`\nshould be used in the assertion. If neither are used, the assertion is\ndefaulted to `all`.\n\nWhen both `all` and `contain` are used, the target object must have at\nleast all of the passed-in keys but may have more keys not listed.\n\nWhen both `all` and `have` are used, the target object must both contain\nall of the passed-in keys AND the number of keys in the target object must\nmatch the number of keys passed in (in other words, a target object must\nhave all and only all of the passed-in keys).\n\n    expect({ foo: 1, bar: 2 }).to.have.any.keys('foo', 'baz');\n    expect({ foo: 1, bar: 2 }).to.have.any.keys('foo');\n    expect({ foo: 1, bar: 2 }).to.contain.any.keys('bar', 'baz');\n    expect({ foo: 1, bar: 2 }).to.contain.any.keys(['foo']);\n    expect({ foo: 1, bar: 2 }).to.contain.any.keys({'foo': 6});\n    expect({ foo: 1, bar: 2 }).to.have.all.keys(['bar', 'foo']);\n    expect({ foo: 1, bar: 2 }).to.have.all.keys({'bar': 6, 'foo': 7});\n    expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys(['bar', 'foo']);\n    expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys({'bar': 6});",
      "summary": "### .keys(key1, [key2], [...])",
      "body": "Asserts that the target contains any or all of the passed-in keys.\nUse in combination with `any`, `all`, `contains`, or `have` will affect\nwhat will pass.\n\nWhen used in conjunction with `any`, at least one key that is passed\nin must exist in the target object. This is regardless whether or not\nthe `have` or `contain` qualifiers are used. Note, either `any` or `all`\nshould be used in the assertion. If neither are used, the assertion is\ndefaulted to `all`.\n\nWhen both `all` and `contain` are used, the target object must have at\nleast all of the passed-in keys but may have more keys not listed.\n\nWhen both `all` and `have` are used, the target object must both contain\nall of the passed-in keys AND the number of keys in the target object must\nmatch the number of keys passed in (in other words, a target object must\nhave all and only all of the passed-in keys).\n\n    expect({ foo: 1, bar: 2 }).to.have.any.keys('foo', 'baz');\n    expect({ foo: 1, bar: 2 }).to.have.any.keys('foo');\n    expect({ foo: 1, bar: 2 }).to.contain.any.keys('bar', 'baz');\n    expect({ foo: 1, bar: 2 }).to.contain.any.keys(['foo']);\n    expect({ foo: 1, bar: 2 }).to.contain.any.keys({'foo': 6});\n    expect({ foo: 1, bar: 2 }).to.have.all.keys(['bar', 'foo']);\n    expect({ foo: 1, bar: 2 }).to.have.all.keys({'bar': 6, 'foo': 7});\n    expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys(['bar', 'foo']);\n    expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys({'bar': 6});"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1400,
    "codeStart": 1439,
    "code": "function assertKeys (keys) {\n  var obj = flag(this, 'object')\n    , str\n    , ok = true\n    , mixedArgsMsg = 'keys must be given single argument of Array|Object|String, or multiple String arguments';\n\n  switch (_.type(keys)) {\n    case \"array\":\n      if (arguments.length > 1) throw (new Error(mixedArgsMsg));\n      break;\n    case \"object\":\n      if (arguments.length > 1) throw (new Error(mixedArgsMsg));\n      keys = Object.keys(keys);\n      break;\n    default:\n      keys = Array.prototype.slice.call(arguments);\n  }\n\n  if (!keys.length) throw new Error('keys required');\n\n  var actual = Object.keys(obj)\n    , expected = keys\n    , len = keys.length\n    , any = flag(this, 'any')\n    , all = flag(this, 'all');\n\n  if (!any && !all) {\n    all = true;\n  }\n\n  // Has any\n  if (any) {\n    var intersection = expected.filter(function(key) {\n      return ~actual.indexOf(key);\n    });\n    ok = intersection.length > 0;\n  }\n\n  // Has all\n  if (all) {\n    ok = keys.every(function(key){\n      return ~actual.indexOf(key);\n    });\n    if (!flag(this, 'negate') && !flag(this, 'contains')) {\n      ok = ok && keys.length == actual.length;\n    }\n  }\n\n  // Key string\n  if (len > 1) {\n    keys = keys.map(function(key){\n      return _.inspect(key);\n    });\n    var last = keys.pop();\n    if (all) {\n      str = keys.join(', ') + ', and ' + last;\n    }\n    if (any) {\n      str = keys.join(', ') + ', or ' + last;\n    }\n  } else {\n    str = _.inspect(keys[0]);\n  }\n\n  // Form\n  str = (len > 1 ? 'keys ' : 'key ') + str;\n\n  // Have / include\n  str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;\n\n  // Assertion\n  this.assert(\n      ok\n    , 'expected #{this} to ' + str\n    , 'expected #{this} to not ' + str\n    , expected.slice(0).sort()\n    , actual.sort()\n    , true\n  );\n}\n\nAssertion.addMethod('keys', assertKeys);\nAssertion.addMethod('key', assertKeys);",
    "ctx": {
      "type": "function",
      "name": "assertKeys",
      "string": "assertKeys()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "throw"
      },
      {
        "type": "alias",
        "string": "throws"
      },
      {
        "type": "alias",
        "string": "Throw"
      },
      {
        "type": "param",
        "string": "{ErrorConstructor} constructor",
        "name": "constructor",
        "description": "",
        "types": [
          "ErrorConstructor"
        ],
        "typesDescription": "<a href=\"ErrorConstructor.html\">ErrorConstructor</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String|RegExp} expected error message",
        "name": "expected",
        "description": "error message",
        "types": [
          "String",
          "RegExp"
        ],
        "typesDescription": "<code>String</code>|<code>RegExp</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "see",
        "string": "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types",
        "title": "",
        "url": "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types"
      },
      {
        "type": "returns",
        "string": "error for chaining (null if no error)",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "error for chaining (null if no error)"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .throw(constructor)\n\nAsserts that the function target will throw a specific error, or specific type of error\n(as determined using `instanceof`), optionally with a RegExp or string inclusion test\nfor the error's message.\n\n    var err = new ReferenceError('This is a bad function.');\n    var fn = function () { throw err; }\n    expect(fn).to.throw(ReferenceError);\n    expect(fn).to.throw(Error);\n    expect(fn).to.throw(/bad function/);\n    expect(fn).to.not.throw('good function');\n    expect(fn).to.throw(ReferenceError, /bad function/);\n    expect(fn).to.throw(err);\n\nPlease note that when a throw expectation is negated, it will check each\nparameter independently, starting with error constructor type. The appropriate way\nto check for the existence of a type of error but for a message that does not match\nis to use `and`.\n\n    expect(fn).to.throw(ReferenceError)\n       .and.not.throw(/good function/);",
      "summary": "### .throw(constructor)",
      "body": "Asserts that the function target will throw a specific error, or specific type of error\n(as determined using `instanceof`), optionally with a RegExp or string inclusion test\nfor the error's message.\n\n    var err = new ReferenceError('This is a bad function.');\n    var fn = function () { throw err; }\n    expect(fn).to.throw(ReferenceError);\n    expect(fn).to.throw(Error);\n    expect(fn).to.throw(/bad function/);\n    expect(fn).to.not.throw('good function');\n    expect(fn).to.throw(ReferenceError, /bad function/);\n    expect(fn).to.throw(err);\n\nPlease note that when a throw expectation is negated, it will check each\nparameter independently, starting with error constructor type. The appropriate way\nto check for the existence of a type of error but for a message that does not match\nis to use `and`.\n\n    expect(fn).to.throw(ReferenceError)\n       .and.not.throw(/good function/);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1523,
    "codeStart": 1559,
    "code": "function assertThrows (constructor, errMsg, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object');\n  new Assertion(obj, msg).is.a('function');\n\n  var thrown = false\n    , desiredError = null\n    , name = null\n    , thrownError = null;\n\n  if (arguments.length === 0) {\n    errMsg = null;\n    constructor = null;\n  } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {\n    errMsg = constructor;\n    constructor = null;\n  } else if (constructor && constructor instanceof Error) {\n    desiredError = constructor;\n    constructor = null;\n    errMsg = null;\n  } else if (typeof constructor === 'function') {\n    name = constructor.prototype.name;\n    if (!name || (name === 'Error' && constructor !== Error)) {\n      name = constructor.name || (new constructor()).name;\n    }\n  } else {\n    constructor = null;\n  }\n\n  try {\n    obj();\n  } catch (err) {\n    // first, check desired error\n    if (desiredError) {\n      this.assert(\n          err === desiredError\n        , 'expected #{this} to throw #{exp} but #{act} was thrown'\n        , 'expected #{this} to not throw #{exp}'\n        , (desiredError instanceof Error ? desiredError.toString() : desiredError)\n        , (err instanceof Error ? err.toString() : err)\n      );\n\n      flag(this, 'object', err);\n      return this;\n    }\n\n    // next, check constructor\n    if (constructor) {\n      this.assert(\n          err instanceof constructor\n        , 'expected #{this} to throw #{exp} but #{act} was thrown'\n        , 'expected #{this} to not throw #{exp} but #{act} was thrown'\n        , name\n        , (err instanceof Error ? err.toString() : err)\n      );\n\n      if (!errMsg) {\n        flag(this, 'object', err);\n        return this;\n      }\n    }\n\n    // next, check message\n    var message = 'error' === _.type(err) && \"message\" in err\n      ? err.message\n      : '' + err;\n\n    if ((message != null) && errMsg && errMsg instanceof RegExp) {\n      this.assert(\n          errMsg.exec(message)\n        , 'expected #{this} to throw error matching #{exp} but got #{act}'\n        , 'expected #{this} to throw error not matching #{exp}'\n        , errMsg\n        , message\n      );\n\n      flag(this, 'object', err);\n      return this;\n    } else if ((message != null) && errMsg && 'string' === typeof errMsg) {\n      this.assert(\n          ~message.indexOf(errMsg)\n        , 'expected #{this} to throw error including #{exp} but got #{act}'\n        , 'expected #{this} to throw error not including #{act}'\n        , errMsg\n        , message\n      );\n\n      flag(this, 'object', err);\n      return this;\n    } else {\n      thrown = true;\n      thrownError = err;\n    }\n  }\n\n  var actuallyGot = ''\n    , expectedThrown = name !== null\n      ? name\n      : desiredError\n        ? '#{exp}' //_.inspect(desiredError)\n        : 'an error';\n\n  if (thrown) {\n    actuallyGot = ' but #{act} was thrown'\n  }\n\n  this.assert(\n      thrown === true\n    , 'expected #{this} to throw ' + expectedThrown + actuallyGot\n    , 'expected #{this} to not throw ' + expectedThrown + actuallyGot\n    , (desiredError instanceof Error ? desiredError.toString() : desiredError)\n    , (thrownError instanceof Error ? thrownError.toString() : thrownError)\n  );\n\n  flag(this, 'object', thrownError);\n};\n\nAssertion.addMethod('throw', assertThrows);\nAssertion.addMethod('throws', assertThrows);\nAssertion.addMethod('Throw', assertThrows);",
    "ctx": {
      "type": "function",
      "name": "assertThrows",
      "string": "assertThrows()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "respondTo"
      },
      {
        "type": "alias",
        "string": "respondsTo"
      },
      {
        "type": "param",
        "string": "{String} method",
        "name": "method",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .respondTo(method)\n\nAsserts that the object or class target will respond to a method.\n\n    Klass.prototype.bar = function(){};\n    expect(Klass).to.respondTo('bar');\n    expect(obj).to.respondTo('bar');\n\nTo check if a constructor will respond to a static function,\nset the `itself` flag.\n\n    Klass.baz = function(){};\n    expect(Klass).itself.to.respondTo('baz');",
      "summary": "### .respondTo(method)",
      "body": "Asserts that the object or class target will respond to a method.\n\n    Klass.prototype.bar = function(){};\n    expect(Klass).to.respondTo('bar');\n    expect(obj).to.respondTo('bar');\n\nTo check if a constructor will respond to a static function,\nset the `itself` flag.\n\n    Klass.baz = function(){};\n    expect(Klass).itself.to.respondTo('baz');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1680,
    "codeStart": 1703,
    "code": "function respondTo (method, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object')\n    , itself = flag(this, 'itself')\n    , context = ('function' === _.type(obj) && !itself)\n      ? obj.prototype[method]\n      : obj[method];\n\n  this.assert(\n      'function' === typeof context\n    , 'expected #{this} to respond to ' + _.inspect(method)\n    , 'expected #{this} to not respond to ' + _.inspect(method)\n  );\n}\n\nAssertion.addMethod('respondTo', respondTo);\nAssertion.addMethod('respondsTo', respondTo);",
    "ctx": {
      "type": "function",
      "name": "respondTo",
      "string": "respondTo()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "itself"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .itself\n\nSets the `itself` flag, later used by the `respondTo` assertion.\n\n    function Foo() {}\n    Foo.bar = function() {}\n    Foo.prototype.baz = function() {}\n\n    expect(Foo).itself.to.respondTo('bar');\n    expect(Foo).itself.not.to.respondTo('baz');",
      "summary": "### .itself",
      "body": "Sets the `itself` flag, later used by the `respondTo` assertion.\n\n    function Foo() {}\n    Foo.bar = function() {}\n    Foo.prototype.baz = function() {}\n\n    expect(Foo).itself.to.respondTo('bar');\n    expect(Foo).itself.not.to.respondTo('baz');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1721,
    "codeStart": 1738,
    "code": "Assertion.addProperty('itself', function () {\n  flag(this, 'itself', true);\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "satisfy"
      },
      {
        "type": "alias",
        "string": "satisfies"
      },
      {
        "type": "param",
        "string": "{Function} matcher",
        "name": "matcher",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .satisfy(method)\n\nAsserts that the target passes a given truth test.\n\n    expect(1).to.satisfy(function(num) { return num > 0; });",
      "summary": "### .satisfy(method)",
      "body": "Asserts that the target passes a given truth test.\n\n    expect(1).to.satisfy(function(num) { return num > 0; });"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1742,
    "codeStart": 1757,
    "code": "function satisfy (matcher, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object');\n  var result = matcher(obj);\n  this.assert(\n      result\n    , 'expected #{this} to satisfy ' + _.objDisplay(matcher)\n    , 'expected #{this} to not satisfy' + _.objDisplay(matcher)\n    , this.negate ? false : true\n    , result\n  );\n}\n\nAssertion.addMethod('satisfy', satisfy);\nAssertion.addMethod('satisfies', satisfy);",
    "ctx": {
      "type": "function",
      "name": "satisfy",
      "string": "satisfy()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "closeTo"
      },
      {
        "type": "alias",
        "string": "approximately"
      },
      {
        "type": "param",
        "string": "{Number} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} delta",
        "name": "delta",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .closeTo(expected, delta)\n\nAsserts that the target is equal `expected`, to within a +/- `delta` range.\n\n    expect(1.5).to.be.closeTo(1, 0.5);",
      "summary": "### .closeTo(expected, delta)",
      "body": "Asserts that the target is equal `expected`, to within a +/- `delta` range.\n\n    expect(1.5).to.be.closeTo(1, 0.5);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1773,
    "codeStart": 1789,
    "code": "function closeTo(expected, delta, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object');\n\n  new Assertion(obj, msg).is.a('number');\n  if (_.type(expected) !== 'number' || _.type(delta) !== 'number') {\n    throw new Error('the arguments to closeTo or approximately must be numbers');\n  }\n\n  this.assert(\n      Math.abs(obj - expected) <= delta\n    , 'expected #{this} to be close to ' + expected + ' +/- ' + delta\n    , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta\n  );\n}\n\nAssertion.addMethod('closeTo', closeTo);\nAssertion.addMethod('approximately', closeTo);\n\nfunction isSubsetOf(subset, superset, cmp) {\n  return subset.every(function(elem) {\n    if (!cmp) return superset.indexOf(elem) !== -1;\n\n    return superset.some(function(elem2) {\n      return cmp(elem, elem2);\n    });\n  })\n}",
    "ctx": {
      "type": "function",
      "name": "closeTo",
      "string": "closeTo()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "members"
      },
      {
        "type": "param",
        "string": "{Array} set",
        "name": "set",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .members(set)\n\nAsserts that the target is a superset of `set`,\nor that the target and `set` have the same strictly-equal (===) members.\nAlternately, if the `deep` flag is set, set members are compared for deep\nequality.\n\n    expect([1, 2, 3]).to.include.members([3, 2]);\n    expect([1, 2, 3]).to.not.include.members([3, 2, 8]);\n\n    expect([4, 2]).to.have.members([2, 4]);\n    expect([5, 2]).to.not.have.members([5, 2, 1]);\n\n    expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);",
      "summary": "### .members(set)",
      "body": "Asserts that the target is a superset of `set`,\nor that the target and `set` have the same strictly-equal (===) members.\nAlternately, if the `deep` flag is set, set members are compared for deep\nequality.\n\n    expect([1, 2, 3]).to.include.members([3, 2]);\n    expect([1, 2, 3]).to.not.include.members([3, 2, 8]);\n\n    expect([4, 2]).to.have.members([2, 4]);\n    expect([5, 2]).to.not.have.members([5, 2, 1]);\n\n    expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1818,
    "codeStart": 1841,
    "code": "Assertion.addMethod('members', function (subset, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object');\n\n  new Assertion(obj).to.be.an('array');\n  new Assertion(subset).to.be.an('array');\n\n  var cmp = flag(this, 'deep') ? _.eql : undefined;\n\n  if (flag(this, 'contains')) {\n    return this.assert(\n        isSubsetOf(subset, obj, cmp)\n      , 'expected #{this} to be a superset of #{act}'\n      , 'expected #{this} to not be a superset of #{act}'\n      , obj\n      , subset\n    );\n  }\n\n  this.assert(\n      isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)\n      , 'expected #{this} to have the same members as #{act}'\n      , 'expected #{this} to not have the same members as #{act}'\n      , obj\n      , subset\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "oneOf"
      },
      {
        "type": "param",
        "string": "{Array<*>} list",
        "name": "list",
        "description": "",
        "types": [
          "Array.<*>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>*</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .oneOf(list)\n\nAssert that a value appears somewhere in the top level of array `list`.\n\n    expect('a').to.be.oneOf(['a', 'b', 'c']);\n    expect(9).to.not.be.oneOf(['z']);\n    expect([3]).to.not.be.oneOf([1, 2, [3]]);\n\n    var three = [3];\n    // for object-types, contents are not compared\n    expect(three).to.not.be.oneOf([1, 2, [3]]);\n    // comparing references works\n    expect(three).to.be.oneOf([1, 2, three]);",
      "summary": "### .oneOf(list)",
      "body": "Assert that a value appears somewhere in the top level of array `list`.\n\n    expect('a').to.be.oneOf(['a', 'b', 'c']);\n    expect(9).to.not.be.oneOf(['z']);\n    expect([3]).to.not.be.oneOf([1, 2, [3]]);\n\n    var three = [3];\n    // for object-types, contents are not compared\n    expect(three).to.not.be.oneOf([1, 2, [3]]);\n    // comparing references works\n    expect(three).to.be.oneOf([1, 2, three]);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1869,
    "codeStart": 1891,
    "code": "function oneOf (list, msg) {\n  if (msg) flag(this, 'message', msg);\n  var expected = flag(this, 'object');\n  new Assertion(list).to.be.an('array');\n\n  this.assert(\n      list.indexOf(expected) > -1\n    , 'expected #{this} to be one of #{exp}'\n    , 'expected #{this} to not be one of #{exp}'\n    , list\n    , expected\n  );\n}\n\nAssertion.addMethod('oneOf', oneOf);",
    "ctx": {
      "type": "function",
      "name": "oneOf",
      "string": "oneOf()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "change"
      },
      {
        "type": "alias",
        "string": "changes"
      },
      {
        "type": "alias",
        "string": "Change"
      },
      {
        "type": "param",
        "string": "{String} object",
        "name": "object",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name",
        "name": "property",
        "description": "name",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .change(function)\n\nAsserts that a function changes an object property\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val += 3 };\n    var noChangeFn = function() { return 'foo' + 'bar'; }\n    expect(fn).to.change(obj, 'val');\n    expect(noChangeFn).to.not.change(obj, 'val')",
      "summary": "### .change(function)",
      "body": "Asserts that a function changes an object property\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val += 3 };\n    var noChangeFn = function() { return 'foo' + 'bar'; }\n    expect(fn).to.change(obj, 'val');\n    expect(noChangeFn).to.not.change(obj, 'val')"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1908,
    "codeStart": 1929,
    "code": "function assertChanges (object, prop, msg) {\n  if (msg) flag(this, 'message', msg);\n  var fn = flag(this, 'object');\n  new Assertion(object, msg).to.have.property(prop);\n  new Assertion(fn).is.a('function');\n\n  var initial = object[prop];\n  fn();\n\n  this.assert(\n    initial !== object[prop]\n    , 'expected .' + prop + ' to change'\n    , 'expected .' + prop + ' to not change'\n  );\n}\n\nAssertion.addChainableMethod('change', assertChanges);\nAssertion.addChainableMethod('changes', assertChanges);",
    "ctx": {
      "type": "function",
      "name": "assertChanges",
      "string": "assertChanges()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "increase"
      },
      {
        "type": "alias",
        "string": "increases"
      },
      {
        "type": "alias",
        "string": "Increase"
      },
      {
        "type": "param",
        "string": "{String} object",
        "name": "object",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name",
        "name": "property",
        "description": "name",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .increase(function)\n\nAsserts that a function increases an object property\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 15 };\n    expect(fn).to.increase(obj, 'val');",
      "summary": "### .increase(function)",
      "body": "Asserts that a function increases an object property\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 15 };\n    expect(fn).to.increase(obj, 'val');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1948,
    "codeStart": 1967,
    "code": "function assertIncreases (object, prop, msg) {\n  if (msg) flag(this, 'message', msg);\n  var fn = flag(this, 'object');\n  new Assertion(object, msg).to.have.property(prop);\n  new Assertion(fn).is.a('function');\n\n  var initial = object[prop];\n  fn();\n\n  this.assert(\n    object[prop] - initial > 0\n    , 'expected .' + prop + ' to increase'\n    , 'expected .' + prop + ' to not increase'\n  );\n}\n\nAssertion.addChainableMethod('increase', assertIncreases);\nAssertion.addChainableMethod('increases', assertIncreases);",
    "ctx": {
      "type": "function",
      "name": "assertIncreases",
      "string": "assertIncreases()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "decrease"
      },
      {
        "type": "alias",
        "string": "decreases"
      },
      {
        "type": "alias",
        "string": "Decrease"
      },
      {
        "type": "param",
        "string": "{String} object",
        "name": "object",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name",
        "name": "property",
        "description": "name",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .decrease(function)\n\nAsserts that a function decreases an object property\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 5 };\n    expect(fn).to.decrease(obj, 'val');",
      "summary": "### .decrease(function)",
      "body": "Asserts that a function decreases an object property\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 5 };\n    expect(fn).to.decrease(obj, 'val');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1986,
    "codeStart": 2005,
    "code": "function assertDecreases (object, prop, msg) {\n  if (msg) flag(this, 'message', msg);\n  var fn = flag(this, 'object');\n  new Assertion(object, msg).to.have.property(prop);\n  new Assertion(fn).is.a('function');\n\n  var initial = object[prop];\n  fn();\n\n  this.assert(\n    object[prop] - initial < 0\n    , 'expected .' + prop + ' to decrease'\n    , 'expected .' + prop + ' to not decrease'\n  );\n}\n\nAssertion.addChainableMethod('decrease', assertDecreases);\nAssertion.addChainableMethod('decreases', assertDecreases);",
    "ctx": {
      "type": "function",
      "name": "assertDecreases",
      "string": "assertDecreases()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "extensible"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .extensible\n\nAsserts that the target is extensible (can have new properties added to\nit).\n\n    var nonExtensibleObject = Object.preventExtensions({});\n    var sealedObject = Object.seal({});\n    var frozenObject = Object.freeze({});\n\n    expect({}).to.be.extensible;\n    expect(nonExtensibleObject).to.not.be.extensible;\n    expect(sealedObject).to.not.be.extensible;\n    expect(frozenObject).to.not.be.extensible;",
      "summary": "### .extensible",
      "body": "Asserts that the target is extensible (can have new properties added to\nit).\n\n    var nonExtensibleObject = Object.preventExtensions({});\n    var sealedObject = Object.seal({});\n    var frozenObject = Object.freeze({});\n\n    expect({}).to.be.extensible;\n    expect(nonExtensibleObject).to.not.be.extensible;\n    expect(sealedObject).to.not.be.extensible;\n    expect(frozenObject).to.not.be.extensible;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2024,
    "codeStart": 2044,
    "code": "Assertion.addProperty('extensible', function() {\n  var obj = flag(this, 'object');\n\n  // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.\n  // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\n  // The following provides ES6 behavior when a TypeError is thrown under ES5.\n\n  var isExtensible;\n\n  try {\n    isExtensible = Object.isExtensible(obj);\n  } catch (err) {\n    if (err instanceof TypeError) isExtensible = false;\n    else throw err;\n  }\n\n  this.assert(\n    isExtensible\n    , 'expected #{this} to be extensible'\n    , 'expected #{this} to not be extensible'\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "sealed"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .sealed\n\nAsserts that the target is sealed (cannot have new properties added to it\nand its existing properties cannot be removed).\n\n    var sealedObject = Object.seal({});\n    var frozenObject = Object.freeze({});\n\n    expect(sealedObject).to.be.sealed;\n    expect(frozenObject).to.be.sealed;\n    expect({}).to.not.be.sealed;",
      "summary": "### .sealed",
      "body": "Asserts that the target is sealed (cannot have new properties added to it\nand its existing properties cannot be removed).\n\n    var sealedObject = Object.seal({});\n    var frozenObject = Object.freeze({});\n\n    expect(sealedObject).to.be.sealed;\n    expect(frozenObject).to.be.sealed;\n    expect({}).to.not.be.sealed;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2068,
    "codeStart": 2086,
    "code": "Assertion.addProperty('sealed', function() {\n  var obj = flag(this, 'object');\n\n  // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.\n  // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.\n  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed\n  // The following provides ES6 behavior when a TypeError is thrown under ES5.\n\n  var isSealed;\n\n  try {\n    isSealed = Object.isSealed(obj);\n  } catch (err) {\n    if (err instanceof TypeError) isSealed = true;\n    else throw err;\n  }\n\n  this.assert(\n    isSealed\n    , 'expected #{this} to be sealed'\n    , 'expected #{this} to not be sealed'\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "frozen"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .frozen\n\nAsserts that the target is frozen (cannot have new properties added to it\nand its existing properties cannot be modified).\n\n    var frozenObject = Object.freeze({});\n\n    expect(frozenObject).to.be.frozen;\n    expect({}).to.not.be.frozen;",
      "summary": "### .frozen",
      "body": "Asserts that the target is frozen (cannot have new properties added to it\nand its existing properties cannot be modified).\n\n    var frozenObject = Object.freeze({});\n\n    expect(frozenObject).to.be.frozen;\n    expect({}).to.not.be.frozen;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2110,
    "codeStart": 2126,
    "code": "Assertion.addProperty('frozen', function() {\n  var obj = flag(this, 'object');\n\n  // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.\n  // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.\n  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\n  // The following provides ES6 behavior when a TypeError is thrown under ES5.\n\n  var isFrozen;\n\n  try {\n    isFrozen = Object.isFrozen(obj);\n  } catch (err) {\n    if (err instanceof TypeError) isFrozen = true;\n    else throw err;\n  }\n\n  this.assert(\n    isFrozen\n    , 'expected #{this} to be frozen'\n    , 'expected #{this} to not be frozen'\n  );\n});\n};\n\n},{}],6:[function(require,module,exports){",
    "ctx": false
  },
  {
    "tags": [],
    "description": {
      "full": "chai\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "chai\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 2152,
    "codeStart": 2159,
    "code": "module.exports = function (chai, util) {",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai dependencies.",
      "summary": "Chai dependencies.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 2161,
    "codeStart": 2165,
    "code": "var Assertion = chai.Assertion\n  , flag = util.flag;",
    "ctx": {
      "type": "declaration",
      "name": "Assertion",
      "value": "chai.Assertion",
      "string": "Assertion"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Module export.",
      "summary": "Module export.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 2168,
    "codeStart": 2171
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} expression to test for truthiness",
        "name": "expression",
        "description": "to test for truthiness",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message to display on error",
        "name": "message",
        "description": "to display on error",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "name",
        "string": "assert"
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### assert(expression, message)\n\nWrite your own test expressions.\n\n    assert('foo' !== 'bar', 'foo is not bar');\n    assert(Array.isArray([]), 'empty arrays are arrays');",
      "summary": "### assert(expression, message)",
      "body": "Write your own test expressions.\n\n    assert('foo' !== 'bar', 'foo is not bar');\n    assert(Array.isArray([]), 'empty arrays are arrays');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2172,
    "codeStart": 2187,
    "code": "var assert = chai.assert = function (express, errmsg) {\n  var test = new Assertion(null, null, chai.assert);\n  test.assert(\n      express\n    , errmsg\n    , '[ negation message unavailable ]'\n  );\n};",
    "ctx": {
      "type": "declaration",
      "name": "assert",
      "value": "chai.assert = function (express, errmsg) {",
      "string": "assert"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "fail"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} operator",
        "name": "operator",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .fail(actual, expected, [message], [operator])\n\nThrow a failure. Node.js `assert` module-compatible.",
      "summary": "### .fail(actual, expected, [message], [operator])",
      "body": "Throw a failure. Node.js `assert` module-compatible."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2196,
    "codeStart": 2210,
    "code": "assert.fail = function (actual, expected, message, operator) {\n  message = message || 'assert.fail()';\n  throw new chai.AssertionError(message, {\n      actual: actual\n    , expected: expected\n    , operator: operator\n  }, assert.fail);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "fail",
      "string": "assert.fail()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isOk"
      },
      {
        "type": "alias",
        "string": "ok"
      },
      {
        "type": "param",
        "string": "{Mixed} object to test",
        "name": "object",
        "description": "to test",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isOk(object, [message])\n\nAsserts that `object` is truthy.\n\n    assert.isOk('everything', 'everything is ok');\n    assert.isOk(false, 'this will fail');",
      "summary": "### .isOk(object, [message])",
      "body": "Asserts that `object` is truthy.\n\n    assert.isOk('everything', 'everything is ok');\n    assert.isOk(false, 'this will fail');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2219,
    "codeStart": 2235,
    "code": "assert.isOk = function (val, msg) {\n  new Assertion(val, msg).is.ok;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isOk",
      "string": "assert.isOk()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotOk"
      },
      {
        "type": "alias",
        "string": "notOk"
      },
      {
        "type": "param",
        "string": "{Mixed} object to test",
        "name": "object",
        "description": "to test",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotOk(object, [message])\n\nAsserts that `object` is falsy.\n\n    assert.isNotOk('everything', 'this will fail');\n    assert.isNotOk(false, 'this will pass');",
      "summary": "### .isNotOk(object, [message])",
      "body": "Asserts that `object` is falsy.\n\n    assert.isNotOk('everything', 'this will fail');\n    assert.isNotOk(false, 'this will pass');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2239,
    "codeStart": 2255,
    "code": "assert.isNotOk = function (val, msg) {\n  new Assertion(val, msg).is.not.ok;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotOk",
      "string": "assert.isNotOk()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "equal"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .equal(actual, expected, [message])\n\nAsserts non-strict equality (`==`) of `actual` and `expected`.\n\n    assert.equal(3, '3', '== coerces values to strings');",
      "summary": "### .equal(actual, expected, [message])",
      "body": "Asserts non-strict equality (`==`) of `actual` and `expected`.\n\n    assert.equal(3, '3', '== coerces values to strings');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2259,
    "codeStart": 2274,
    "code": "assert.equal = function (act, exp, msg) {\n  var test = new Assertion(act, msg, assert.equal);\n\n  test.assert(\n      exp == flag(test, 'object')\n    , 'expected #{this} to equal #{exp}'\n    , 'expected #{this} to not equal #{act}'\n    , exp\n    , act\n  );\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "equal",
      "string": "assert.equal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notEqual"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notEqual(actual, expected, [message])\n\nAsserts non-strict inequality (`!=`) of `actual` and `expected`.\n\n    assert.notEqual(3, 4, 'these numbers are not equal');",
      "summary": "### .notEqual(actual, expected, [message])",
      "body": "Asserts non-strict inequality (`!=`) of `actual` and `expected`.\n\n    assert.notEqual(3, 4, 'these numbers are not equal');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2286,
    "codeStart": 2301,
    "code": "assert.notEqual = function (act, exp, msg) {\n  var test = new Assertion(act, msg, assert.notEqual);\n\n  test.assert(\n      exp != flag(test, 'object')\n    , 'expected #{this} to not equal #{exp}'\n    , 'expected #{this} to equal #{act}'\n    , exp\n    , act\n  );\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notEqual",
      "string": "assert.notEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "strictEqual"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .strictEqual(actual, expected, [message])\n\nAsserts strict equality (`===`) of `actual` and `expected`.\n\n    assert.strictEqual(true, true, 'these booleans are strictly equal');",
      "summary": "### .strictEqual(actual, expected, [message])",
      "body": "Asserts strict equality (`===`) of `actual` and `expected`.\n\n    assert.strictEqual(true, true, 'these booleans are strictly equal');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2313,
    "codeStart": 2328,
    "code": "assert.strictEqual = function (act, exp, msg) {\n  new Assertion(act, msg).to.equal(exp);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "strictEqual",
      "string": "assert.strictEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notStrictEqual"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notStrictEqual(actual, expected, [message])\n\nAsserts strict inequality (`!==`) of `actual` and `expected`.\n\n    assert.notStrictEqual(3, '3', 'no coercion for strict equality');",
      "summary": "### .notStrictEqual(actual, expected, [message])",
      "body": "Asserts strict inequality (`!==`) of `actual` and `expected`.\n\n    assert.notStrictEqual(3, '3', 'no coercion for strict equality');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2332,
    "codeStart": 2347,
    "code": "assert.notStrictEqual = function (act, exp, msg) {\n  new Assertion(act, msg).to.not.equal(exp);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notStrictEqual",
      "string": "assert.notStrictEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "deepEqual"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .deepEqual(actual, expected, [message])\n\nAsserts that `actual` is deeply equal to `expected`.\n\n    assert.deepEqual({ tea: 'green' }, { tea: 'green' });",
      "summary": "### .deepEqual(actual, expected, [message])",
      "body": "Asserts that `actual` is deeply equal to `expected`.\n\n    assert.deepEqual({ tea: 'green' }, { tea: 'green' });"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2351,
    "codeStart": 2366,
    "code": "assert.deepEqual = function (act, exp, msg) {\n  new Assertion(act, msg).to.eql(exp);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "deepEqual",
      "string": "assert.deepEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notDeepEqual"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notDeepEqual(actual, expected, [message])\n\nAssert that `actual` is not deeply equal to `expected`.\n\n    assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });",
      "summary": "### .notDeepEqual(actual, expected, [message])",
      "body": "Assert that `actual` is not deeply equal to `expected`.\n\n    assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2370,
    "codeStart": 2385,
    "code": "assert.notDeepEqual = function (act, exp, msg) {\n  new Assertion(act, msg).to.not.eql(exp);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notDeepEqual",
      "string": "assert.notDeepEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isAbove"
      },
      {
        "type": "param",
        "string": "{Mixed} valueToCheck",
        "name": "valueToCheck",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} valueToBeAbove",
        "name": "valueToBeAbove",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isAbove(valueToCheck, valueToBeAbove, [message])\n\nAsserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`\n\n    assert.isAbove(5, 2, '5 is strictly greater than 2');",
      "summary": "### .isAbove(valueToCheck, valueToBeAbove, [message])",
      "body": "Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`\n\n    assert.isAbove(5, 2, '5 is strictly greater than 2');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2389,
    "codeStart": 2404,
    "code": "assert.isAbove = function (val, abv, msg) {\n  new Assertion(val, msg).to.be.above(abv);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isAbove",
      "string": "assert.isAbove()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isAtLeast"
      },
      {
        "type": "param",
        "string": "{Mixed} valueToCheck",
        "name": "valueToCheck",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} valueToBeAtLeast",
        "name": "valueToBeAtLeast",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])\n\nAsserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`\n\n    assert.isAtLeast(5, 2, '5 is greater or equal to 2');\n    assert.isAtLeast(3, 3, '3 is greater or equal to 3');",
      "summary": "### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])",
      "body": "Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`\n\n    assert.isAtLeast(5, 2, '5 is greater or equal to 2');\n    assert.isAtLeast(3, 3, '3 is greater or equal to 3');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2408,
    "codeStart": 2424,
    "code": "assert.isAtLeast = function (val, atlst, msg) {\n  new Assertion(val, msg).to.be.least(atlst);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isAtLeast",
      "string": "assert.isAtLeast()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isBelow"
      },
      {
        "type": "param",
        "string": "{Mixed} valueToCheck",
        "name": "valueToCheck",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} valueToBeBelow",
        "name": "valueToBeBelow",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isBelow(valueToCheck, valueToBeBelow, [message])\n\nAsserts `valueToCheck` is strictly less than (<) `valueToBeBelow`\n\n    assert.isBelow(3, 6, '3 is strictly less than 6');",
      "summary": "### .isBelow(valueToCheck, valueToBeBelow, [message])",
      "body": "Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`\n\n    assert.isBelow(3, 6, '3 is strictly less than 6');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2428,
    "codeStart": 2443,
    "code": "assert.isBelow = function (val, blw, msg) {\n  new Assertion(val, msg).to.be.below(blw);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isBelow",
      "string": "assert.isBelow()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isAtMost"
      },
      {
        "type": "param",
        "string": "{Mixed} valueToCheck",
        "name": "valueToCheck",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} valueToBeAtMost",
        "name": "valueToBeAtMost",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isAtMost(valueToCheck, valueToBeAtMost, [message])\n\nAsserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`\n\n    assert.isAtMost(3, 6, '3 is less than or equal to 6');\n    assert.isAtMost(4, 4, '4 is less than or equal to 4');",
      "summary": "### .isAtMost(valueToCheck, valueToBeAtMost, [message])",
      "body": "Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`\n\n    assert.isAtMost(3, 6, '3 is less than or equal to 6');\n    assert.isAtMost(4, 4, '4 is less than or equal to 4');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2447,
    "codeStart": 2463,
    "code": "assert.isAtMost = function (val, atmst, msg) {\n  new Assertion(val, msg).to.be.most(atmst);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isAtMost",
      "string": "assert.isAtMost()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isTrue"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isTrue(value, [message])\n\nAsserts that `value` is true.\n\n    var teaServed = true;\n    assert.isTrue(teaServed, 'the tea has been served');",
      "summary": "### .isTrue(value, [message])",
      "body": "Asserts that `value` is true.\n\n    var teaServed = true;\n    assert.isTrue(teaServed, 'the tea has been served');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2467,
    "codeStart": 2482,
    "code": "assert.isTrue = function (val, msg) {\n  new Assertion(val, msg).is['true'];\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isTrue",
      "string": "assert.isTrue()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotTrue"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotTrue(value, [message])\n\nAsserts that `value` is not true.\n\n    var tea = 'tasty chai';\n    assert.isNotTrue(tea, 'great, time for tea!');",
      "summary": "### .isNotTrue(value, [message])",
      "body": "Asserts that `value` is not true.\n\n    var tea = 'tasty chai';\n    assert.isNotTrue(tea, 'great, time for tea!');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2486,
    "codeStart": 2501,
    "code": "assert.isNotTrue = function (val, msg) {\n  new Assertion(val, msg).to.not.equal(true);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotTrue",
      "string": "assert.isNotTrue()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isFalse"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isFalse(value, [message])\n\nAsserts that `value` is false.\n\n    var teaServed = false;\n    assert.isFalse(teaServed, 'no tea yet? hmm...');",
      "summary": "### .isFalse(value, [message])",
      "body": "Asserts that `value` is false.\n\n    var teaServed = false;\n    assert.isFalse(teaServed, 'no tea yet? hmm...');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2505,
    "codeStart": 2520,
    "code": "assert.isFalse = function (val, msg) {\n  new Assertion(val, msg).is['false'];\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isFalse",
      "string": "assert.isFalse()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotFalse"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotFalse(value, [message])\n\nAsserts that `value` is not false.\n\n    var tea = 'tasty chai';\n    assert.isNotFalse(tea, 'great, time for tea!');",
      "summary": "### .isNotFalse(value, [message])",
      "body": "Asserts that `value` is not false.\n\n    var tea = 'tasty chai';\n    assert.isNotFalse(tea, 'great, time for tea!');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2524,
    "codeStart": 2539,
    "code": "assert.isNotFalse = function (val, msg) {\n  new Assertion(val, msg).to.not.equal(false);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotFalse",
      "string": "assert.isNotFalse()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNull"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNull(value, [message])\n\nAsserts that `value` is null.\n\n    assert.isNull(err, 'there was no error');",
      "summary": "### .isNull(value, [message])",
      "body": "Asserts that `value` is null.\n\n    assert.isNull(err, 'there was no error');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2543,
    "codeStart": 2557,
    "code": "assert.isNull = function (val, msg) {\n  new Assertion(val, msg).to.equal(null);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNull",
      "string": "assert.isNull()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotNull"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotNull(value, [message])\n\nAsserts that `value` is not null.\n\n    var tea = 'tasty chai';\n    assert.isNotNull(tea, 'great, time for tea!');",
      "summary": "### .isNotNull(value, [message])",
      "body": "Asserts that `value` is not null.\n\n    var tea = 'tasty chai';\n    assert.isNotNull(tea, 'great, time for tea!');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2561,
    "codeStart": 2576,
    "code": "assert.isNotNull = function (val, msg) {\n  new Assertion(val, msg).to.not.equal(null);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotNull",
      "string": "assert.isNotNull()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNaN"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNaN\nAsserts that value is NaN\n\n   assert.isNaN('foo', 'foo is NaN');",
      "summary": "### .isNaN\nAsserts that value is NaN",
      "body": "   assert.isNaN('foo', 'foo is NaN');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2580,
    "codeStart": 2593,
    "code": "assert.isNaN = function (val, msg) {\n  new Assertion(val, msg).to.be.NaN;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNaN",
      "string": "assert.isNaN()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotNaN"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotNaN\nAsserts that value is not NaN\n\n   assert.isNotNaN(4, '4 is not NaN');",
      "summary": "### .isNotNaN\nAsserts that value is not NaN",
      "body": "   assert.isNotNaN(4, '4 is not NaN');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2597,
    "codeStart": 2609,
    "code": "assert.isNotNaN = function (val, msg) {\n  new Assertion(val, msg).not.to.be.NaN;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotNaN",
      "string": "assert.isNotNaN()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isUndefined"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isUndefined(value, [message])\n\nAsserts that `value` is `undefined`.\n\n    var tea;\n    assert.isUndefined(tea, 'no tea defined');",
      "summary": "### .isUndefined(value, [message])",
      "body": "Asserts that `value` is `undefined`.\n\n    var tea;\n    assert.isUndefined(tea, 'no tea defined');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2613,
    "codeStart": 2628,
    "code": "assert.isUndefined = function (val, msg) {\n  new Assertion(val, msg).to.equal(undefined);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isUndefined",
      "string": "assert.isUndefined()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isDefined"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isDefined(value, [message])\n\nAsserts that `value` is not `undefined`.\n\n    var tea = 'cup of chai';\n    assert.isDefined(tea, 'tea has been defined');",
      "summary": "### .isDefined(value, [message])",
      "body": "Asserts that `value` is not `undefined`.\n\n    var tea = 'cup of chai';\n    assert.isDefined(tea, 'tea has been defined');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2632,
    "codeStart": 2647,
    "code": "assert.isDefined = function (val, msg) {\n  new Assertion(val, msg).to.not.equal(undefined);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isDefined",
      "string": "assert.isDefined()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isFunction"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isFunction(value, [message])\n\nAsserts that `value` is a function.\n\n    function serveTea() { return 'cup of tea'; };\n    assert.isFunction(serveTea, 'great, we can have tea now');",
      "summary": "### .isFunction(value, [message])",
      "body": "Asserts that `value` is a function.\n\n    function serveTea() { return 'cup of tea'; };\n    assert.isFunction(serveTea, 'great, we can have tea now');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2651,
    "codeStart": 2666,
    "code": "assert.isFunction = function (val, msg) {\n  new Assertion(val, msg).to.be.a('function');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isFunction",
      "string": "assert.isFunction()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotFunction"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotFunction(value, [message])\n\nAsserts that `value` is _not_ a function.\n\n    var serveTea = [ 'heat', 'pour', 'sip' ];\n    assert.isNotFunction(serveTea, 'great, we have listed the steps');",
      "summary": "### .isNotFunction(value, [message])",
      "body": "Asserts that `value` is _not_ a function.\n\n    var serveTea = [ 'heat', 'pour', 'sip' ];\n    assert.isNotFunction(serveTea, 'great, we have listed the steps');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2670,
    "codeStart": 2685,
    "code": "assert.isNotFunction = function (val, msg) {\n  new Assertion(val, msg).to.not.be.a('function');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotFunction",
      "string": "assert.isNotFunction()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isObject"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isObject(value, [message])\n\nAsserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).\n_The assertion does not match subclassed objects._\n\n    var selection = { name: 'Chai', serve: 'with spices' };\n    assert.isObject(selection, 'tea selection is an object');",
      "summary": "### .isObject(value, [message])",
      "body": "Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).\n_The assertion does not match subclassed objects._\n\n    var selection = { name: 'Chai', serve: 'with spices' };\n    assert.isObject(selection, 'tea selection is an object');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2689,
    "codeStart": 2705,
    "code": "assert.isObject = function (val, msg) {\n  new Assertion(val, msg).to.be.a('object');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isObject",
      "string": "assert.isObject()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotObject"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotObject(value, [message])\n\nAsserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).\n\n    var selection = 'chai'\n    assert.isNotObject(selection, 'tea selection is not an object');\n    assert.isNotObject(null, 'null is not an object');",
      "summary": "### .isNotObject(value, [message])",
      "body": "Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).\n\n    var selection = 'chai'\n    assert.isNotObject(selection, 'tea selection is not an object');\n    assert.isNotObject(null, 'null is not an object');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2709,
    "codeStart": 2725,
    "code": "assert.isNotObject = function (val, msg) {\n  new Assertion(val, msg).to.not.be.a('object');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotObject",
      "string": "assert.isNotObject()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isArray"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isArray(value, [message])\n\nAsserts that `value` is an array.\n\n    var menu = [ 'green', 'chai', 'oolong' ];\n    assert.isArray(menu, 'what kind of tea do we want?');",
      "summary": "### .isArray(value, [message])",
      "body": "Asserts that `value` is an array.\n\n    var menu = [ 'green', 'chai', 'oolong' ];\n    assert.isArray(menu, 'what kind of tea do we want?');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2729,
    "codeStart": 2744,
    "code": "assert.isArray = function (val, msg) {\n  new Assertion(val, msg).to.be.an('array');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isArray",
      "string": "assert.isArray()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotArray"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotArray(value, [message])\n\nAsserts that `value` is _not_ an array.\n\n    var menu = 'green|chai|oolong';\n    assert.isNotArray(menu, 'what kind of tea do we want?');",
      "summary": "### .isNotArray(value, [message])",
      "body": "Asserts that `value` is _not_ an array.\n\n    var menu = 'green|chai|oolong';\n    assert.isNotArray(menu, 'what kind of tea do we want?');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2748,
    "codeStart": 2763,
    "code": "assert.isNotArray = function (val, msg) {\n  new Assertion(val, msg).to.not.be.an('array');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotArray",
      "string": "assert.isNotArray()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isString"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isString(value, [message])\n\nAsserts that `value` is a string.\n\n    var teaOrder = 'chai';\n    assert.isString(teaOrder, 'order placed');",
      "summary": "### .isString(value, [message])",
      "body": "Asserts that `value` is a string.\n\n    var teaOrder = 'chai';\n    assert.isString(teaOrder, 'order placed');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2767,
    "codeStart": 2782,
    "code": "assert.isString = function (val, msg) {\n  new Assertion(val, msg).to.be.a('string');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isString",
      "string": "assert.isString()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotString"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotString(value, [message])\n\nAsserts that `value` is _not_ a string.\n\n    var teaOrder = 4;\n    assert.isNotString(teaOrder, 'order placed');",
      "summary": "### .isNotString(value, [message])",
      "body": "Asserts that `value` is _not_ a string.\n\n    var teaOrder = 4;\n    assert.isNotString(teaOrder, 'order placed');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2786,
    "codeStart": 2801,
    "code": "assert.isNotString = function (val, msg) {\n  new Assertion(val, msg).to.not.be.a('string');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotString",
      "string": "assert.isNotString()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNumber"
      },
      {
        "type": "param",
        "string": "{Number} value",
        "name": "value",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNumber(value, [message])\n\nAsserts that `value` is a number.\n\n    var cups = 2;\n    assert.isNumber(cups, 'how many cups');",
      "summary": "### .isNumber(value, [message])",
      "body": "Asserts that `value` is a number.\n\n    var cups = 2;\n    assert.isNumber(cups, 'how many cups');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2805,
    "codeStart": 2820,
    "code": "assert.isNumber = function (val, msg) {\n  new Assertion(val, msg).to.be.a('number');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNumber",
      "string": "assert.isNumber()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotNumber"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotNumber(value, [message])\n\nAsserts that `value` is _not_ a number.\n\n    var cups = '2 cups please';\n    assert.isNotNumber(cups, 'how many cups');",
      "summary": "### .isNotNumber(value, [message])",
      "body": "Asserts that `value` is _not_ a number.\n\n    var cups = '2 cups please';\n    assert.isNotNumber(cups, 'how many cups');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2824,
    "codeStart": 2839,
    "code": "assert.isNotNumber = function (val, msg) {\n  new Assertion(val, msg).to.not.be.a('number');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotNumber",
      "string": "assert.isNotNumber()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isBoolean"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isBoolean(value, [message])\n\nAsserts that `value` is a boolean.\n\n    var teaReady = true\n      , teaServed = false;\n\n    assert.isBoolean(teaReady, 'is the tea ready');\n    assert.isBoolean(teaServed, 'has tea been served');",
      "summary": "### .isBoolean(value, [message])",
      "body": "Asserts that `value` is a boolean.\n\n    var teaReady = true\n      , teaServed = false;\n\n    assert.isBoolean(teaReady, 'is the tea ready');\n    assert.isBoolean(teaServed, 'has tea been served');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2843,
    "codeStart": 2861,
    "code": "assert.isBoolean = function (val, msg) {\n  new Assertion(val, msg).to.be.a('boolean');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isBoolean",
      "string": "assert.isBoolean()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotBoolean"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotBoolean(value, [message])\n\nAsserts that `value` is _not_ a boolean.\n\n    var teaReady = 'yep'\n      , teaServed = 'nope';\n\n    assert.isNotBoolean(teaReady, 'is the tea ready');\n    assert.isNotBoolean(teaServed, 'has tea been served');",
      "summary": "### .isNotBoolean(value, [message])",
      "body": "Asserts that `value` is _not_ a boolean.\n\n    var teaReady = 'yep'\n      , teaServed = 'nope';\n\n    assert.isNotBoolean(teaReady, 'is the tea ready');\n    assert.isNotBoolean(teaServed, 'has tea been served');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2865,
    "codeStart": 2883,
    "code": "assert.isNotBoolean = function (val, msg) {\n  new Assertion(val, msg).to.not.be.a('boolean');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotBoolean",
      "string": "assert.isNotBoolean()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "typeOf"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} name",
        "name": "name",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .typeOf(value, name, [message])\n\nAsserts that `value`'s type is `name`, as determined by\n`Object.prototype.toString`.\n\n    assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');\n    assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');\n    assert.typeOf('tea', 'string', 'we have a string');\n    assert.typeOf(/tea/, 'regexp', 'we have a regular expression');\n    assert.typeOf(null, 'null', 'we have a null');\n    assert.typeOf(undefined, 'undefined', 'we have an undefined');",
      "summary": "### .typeOf(value, name, [message])",
      "body": "Asserts that `value`'s type is `name`, as determined by\n`Object.prototype.toString`.\n\n    assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');\n    assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');\n    assert.typeOf('tea', 'string', 'we have a string');\n    assert.typeOf(/tea/, 'regexp', 'we have a regular expression');\n    assert.typeOf(null, 'null', 'we have a null');\n    assert.typeOf(undefined, 'undefined', 'we have an undefined');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2887,
    "codeStart": 2908,
    "code": "assert.typeOf = function (val, type, msg) {\n  new Assertion(val, msg).to.be.a(type);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "typeOf",
      "string": "assert.typeOf()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notTypeOf"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} typeof name",
        "name": "typeof",
        "description": "name",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notTypeOf(value, name, [message])\n\nAsserts that `value`'s type is _not_ `name`, as determined by\n`Object.prototype.toString`.\n\n    assert.notTypeOf('tea', 'number', 'strings are not numbers');",
      "summary": "### .notTypeOf(value, name, [message])",
      "body": "Asserts that `value`'s type is _not_ `name`, as determined by\n`Object.prototype.toString`.\n\n    assert.notTypeOf('tea', 'number', 'strings are not numbers');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2912,
    "codeStart": 2928,
    "code": "assert.notTypeOf = function (val, type, msg) {\n  new Assertion(val, msg).to.not.be.a(type);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notTypeOf",
      "string": "assert.notTypeOf()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "instanceOf"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Constructor} constructor",
        "name": "constructor",
        "description": "",
        "types": [
          "Constructor"
        ],
        "typesDescription": "<a href=\"Constructor.html\">Constructor</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .instanceOf(object, constructor, [message])\n\nAsserts that `value` is an instance of `constructor`.\n\n    var Tea = function (name) { this.name = name; }\n      , chai = new Tea('chai');\n\n    assert.instanceOf(chai, Tea, 'chai is an instance of tea');",
      "summary": "### .instanceOf(object, constructor, [message])",
      "body": "Asserts that `value` is an instance of `constructor`.\n\n    var Tea = function (name) { this.name = name; }\n      , chai = new Tea('chai');\n\n    assert.instanceOf(chai, Tea, 'chai is an instance of tea');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2932,
    "codeStart": 2950,
    "code": "assert.instanceOf = function (val, type, msg) {\n  new Assertion(val, msg).to.be.instanceOf(type);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "instanceOf",
      "string": "assert.instanceOf()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notInstanceOf"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Constructor} constructor",
        "name": "constructor",
        "description": "",
        "types": [
          "Constructor"
        ],
        "typesDescription": "<a href=\"Constructor.html\">Constructor</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notInstanceOf(object, constructor, [message])\n\nAsserts `value` is not an instance of `constructor`.\n\n    var Tea = function (name) { this.name = name; }\n      , chai = new String('chai');\n\n    assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');",
      "summary": "### .notInstanceOf(object, constructor, [message])",
      "body": "Asserts `value` is not an instance of `constructor`.\n\n    var Tea = function (name) { this.name = name; }\n      , chai = new String('chai');\n\n    assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2954,
    "codeStart": 2972,
    "code": "assert.notInstanceOf = function (val, type, msg) {\n  new Assertion(val, msg).to.not.be.instanceOf(type);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notInstanceOf",
      "string": "assert.notInstanceOf()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "include"
      },
      {
        "type": "param",
        "string": "{Array|String} haystack",
        "name": "haystack",
        "description": "",
        "types": [
          "Array",
          "String"
        ],
        "typesDescription": "<code>Array</code>|<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} needle",
        "name": "needle",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .include(haystack, needle, [message])\n\nAsserts that `haystack` includes `needle`. Works\nfor strings and arrays.\n\n    assert.include('foobar', 'bar', 'foobar contains string \"bar\"');\n    assert.include([ 1, 2, 3 ], 3, 'array contains value');",
      "summary": "### .include(haystack, needle, [message])",
      "body": "Asserts that `haystack` includes `needle`. Works\nfor strings and arrays.\n\n    assert.include('foobar', 'bar', 'foobar contains string \"bar\"');\n    assert.include([ 1, 2, 3 ], 3, 'array contains value');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2976,
    "codeStart": 2993,
    "code": "assert.include = function (exp, inc, msg) {\n  new Assertion(exp, msg, assert.include).include(inc);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "include",
      "string": "assert.include()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notInclude"
      },
      {
        "type": "param",
        "string": "{Array|String} haystack",
        "name": "haystack",
        "description": "",
        "types": [
          "Array",
          "String"
        ],
        "typesDescription": "<code>Array</code>|<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} needle",
        "name": "needle",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notInclude(haystack, needle, [message])\n\nAsserts that `haystack` does not include `needle`. Works\nfor strings and arrays.\n\n    assert.notInclude('foobar', 'baz', 'string not include substring');\n    assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');",
      "summary": "### .notInclude(haystack, needle, [message])",
      "body": "Asserts that `haystack` does not include `needle`. Works\nfor strings and arrays.\n\n    assert.notInclude('foobar', 'baz', 'string not include substring');\n    assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2997,
    "codeStart": 3014,
    "code": "assert.notInclude = function (exp, inc, msg) {\n  new Assertion(exp, msg, assert.notInclude).not.include(inc);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notInclude",
      "string": "assert.notInclude()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "match"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{RegExp} regexp",
        "name": "regexp",
        "description": "",
        "types": [
          "RegExp"
        ],
        "typesDescription": "<code>RegExp</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .match(value, regexp, [message])\n\nAsserts that `value` matches the regular expression `regexp`.\n\n    assert.match('foobar', /^foo/, 'regexp matches');",
      "summary": "### .match(value, regexp, [message])",
      "body": "Asserts that `value` matches the regular expression `regexp`.\n\n    assert.match('foobar', /^foo/, 'regexp matches');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3018,
    "codeStart": 3033,
    "code": "assert.match = function (exp, re, msg) {\n  new Assertion(exp, msg).to.match(re);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "match",
      "string": "assert.match()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notMatch"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{RegExp} regexp",
        "name": "regexp",
        "description": "",
        "types": [
          "RegExp"
        ],
        "typesDescription": "<code>RegExp</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notMatch(value, regexp, [message])\n\nAsserts that `value` does not match the regular expression `regexp`.\n\n    assert.notMatch('foobar', /^foo/, 'regexp does not match');",
      "summary": "### .notMatch(value, regexp, [message])",
      "body": "Asserts that `value` does not match the regular expression `regexp`.\n\n    assert.notMatch('foobar', /^foo/, 'regexp does not match');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3037,
    "codeStart": 3052,
    "code": "assert.notMatch = function (exp, re, msg) {\n  new Assertion(exp, msg).to.not.match(re);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notMatch",
      "string": "assert.notMatch()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "property"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .property(object, property, [message])\n\nAsserts that `object` has a property named by `property`.\n\n    assert.property({ tea: { green: 'matcha' }}, 'tea');",
      "summary": "### .property(object, property, [message])",
      "body": "Asserts that `object` has a property named by `property`.\n\n    assert.property({ tea: { green: 'matcha' }}, 'tea');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3056,
    "codeStart": 3071,
    "code": "assert.property = function (obj, prop, msg) {\n  new Assertion(obj, msg).to.have.property(prop);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "property",
      "string": "assert.property()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notProperty"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notProperty(object, property, [message])\n\nAsserts that `object` does _not_ have a property named by `property`.\n\n    assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');",
      "summary": "### .notProperty(object, property, [message])",
      "body": "Asserts that `object` does _not_ have a property named by `property`.\n\n    assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3075,
    "codeStart": 3090,
    "code": "assert.notProperty = function (obj, prop, msg) {\n  new Assertion(obj, msg).to.not.have.property(prop);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notProperty",
      "string": "assert.notProperty()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "deepProperty"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .deepProperty(object, property, [message])\n\nAsserts that `object` has a property named by `property`, which can be a\nstring using dot- and bracket-notation for deep reference.\n\n    assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');",
      "summary": "### .deepProperty(object, property, [message])",
      "body": "Asserts that `object` has a property named by `property`, which can be a\nstring using dot- and bracket-notation for deep reference.\n\n    assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3094,
    "codeStart": 3110,
    "code": "assert.deepProperty = function (obj, prop, msg) {\n  new Assertion(obj, msg).to.have.deep.property(prop);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "deepProperty",
      "string": "assert.deepProperty()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notDeepProperty"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notDeepProperty(object, property, [message])\n\nAsserts that `object` does _not_ have a property named by `property`, which\ncan be a string using dot- and bracket-notation for deep reference.\n\n    assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');",
      "summary": "### .notDeepProperty(object, property, [message])",
      "body": "Asserts that `object` does _not_ have a property named by `property`, which\ncan be a string using dot- and bracket-notation for deep reference.\n\n    assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3114,
    "codeStart": 3130,
    "code": "assert.notDeepProperty = function (obj, prop, msg) {\n  new Assertion(obj, msg).to.not.have.deep.property(prop);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notDeepProperty",
      "string": "assert.notDeepProperty()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "propertyVal"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .propertyVal(object, property, value, [message])\n\nAsserts that `object` has a property named by `property` with value given\nby `value`.\n\n    assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');",
      "summary": "### .propertyVal(object, property, value, [message])",
      "body": "Asserts that `object` has a property named by `property` with value given\nby `value`.\n\n    assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3134,
    "codeStart": 3151,
    "code": "assert.propertyVal = function (obj, prop, val, msg) {\n  new Assertion(obj, msg).to.have.property(prop, val);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "propertyVal",
      "string": "assert.propertyVal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "propertyNotVal"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .propertyNotVal(object, property, value, [message])\n\nAsserts that `object` has a property named by `property`, but with a value\ndifferent from that given by `value`.\n\n    assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');",
      "summary": "### .propertyNotVal(object, property, value, [message])",
      "body": "Asserts that `object` has a property named by `property`, but with a value\ndifferent from that given by `value`.\n\n    assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3155,
    "codeStart": 3172,
    "code": "assert.propertyNotVal = function (obj, prop, val, msg) {\n  new Assertion(obj, msg).to.not.have.property(prop, val);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "propertyNotVal",
      "string": "assert.propertyNotVal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "deepPropertyVal"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .deepPropertyVal(object, property, value, [message])\n\nAsserts that `object` has a property named by `property` with value given\nby `value`. `property` can use dot- and bracket-notation for deep\nreference.\n\n    assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');",
      "summary": "### .deepPropertyVal(object, property, value, [message])",
      "body": "Asserts that `object` has a property named by `property` with value given\nby `value`. `property` can use dot- and bracket-notation for deep\nreference.\n\n    assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3176,
    "codeStart": 3194,
    "code": "assert.deepPropertyVal = function (obj, prop, val, msg) {\n  new Assertion(obj, msg).to.have.deep.property(prop, val);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "deepPropertyVal",
      "string": "assert.deepPropertyVal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "deepPropertyNotVal"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .deepPropertyNotVal(object, property, value, [message])\n\nAsserts that `object` has a property named by `property`, but with a value\ndifferent from that given by `value`. `property` can use dot- and\nbracket-notation for deep reference.\n\n    assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');",
      "summary": "### .deepPropertyNotVal(object, property, value, [message])",
      "body": "Asserts that `object` has a property named by `property`, but with a value\ndifferent from that given by `value`. `property` can use dot- and\nbracket-notation for deep reference.\n\n    assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3198,
    "codeStart": 3216,
    "code": "assert.deepPropertyNotVal = function (obj, prop, val, msg) {\n  new Assertion(obj, msg).to.not.have.deep.property(prop, val);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "deepPropertyNotVal",
      "string": "assert.deepPropertyNotVal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "lengthOf"
      },
      {
        "type": "param",
        "string": "{Mixed} object",
        "name": "object",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} length",
        "name": "length",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .lengthOf(object, length, [message])\n\nAsserts that `object` has a `length` property with the expected value.\n\n    assert.lengthOf([1,2,3], 3, 'array has length of 3');\n    assert.lengthOf('foobar', 6, 'string has length of 6');",
      "summary": "### .lengthOf(object, length, [message])",
      "body": "Asserts that `object` has a `length` property with the expected value.\n\n    assert.lengthOf([1,2,3], 3, 'array has length of 3');\n    assert.lengthOf('foobar', 6, 'string has length of 6');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3220,
    "codeStart": 3236,
    "code": "assert.lengthOf = function (exp, len, msg) {\n  new Assertion(exp, msg).to.have.length(len);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "lengthOf",
      "string": "assert.lengthOf()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "throws"
      },
      {
        "type": "alias",
        "string": "throw"
      },
      {
        "type": "alias",
        "string": "Throw"
      },
      {
        "type": "param",
        "string": "{Function} function",
        "name": "function",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{ErrorConstructor} constructor",
        "name": "constructor",
        "description": "",
        "types": [
          "ErrorConstructor"
        ],
        "typesDescription": "<a href=\"ErrorConstructor.html\">ErrorConstructor</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{RegExp} regexp",
        "name": "regexp",
        "description": "",
        "types": [
          "RegExp"
        ],
        "typesDescription": "<code>RegExp</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "see",
        "string": "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types",
        "title": "",
        "url": "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types"
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .throws(function, [constructor/string/regexp], [string/regexp], [message])\n\nAsserts that `function` will throw an error that is an instance of\n`constructor`, or alternately that it will throw an error with message\nmatching `regexp`.\n\n    assert.throws(fn, 'function throws a reference error');\n    assert.throws(fn, /function throws a reference error/);\n    assert.throws(fn, ReferenceError);\n    assert.throws(fn, ReferenceError, 'function throws a reference error');\n    assert.throws(fn, ReferenceError, /function throws a reference error/);",
      "summary": "### .throws(function, [constructor/string/regexp], [string/regexp], [message])",
      "body": "Asserts that `function` will throw an error that is an instance of\n`constructor`, or alternately that it will throw an error with message\nmatching `regexp`.\n\n    assert.throws(fn, 'function throws a reference error');\n    assert.throws(fn, /function throws a reference error/);\n    assert.throws(fn, ReferenceError);\n    assert.throws(fn, ReferenceError, 'function throws a reference error');\n    assert.throws(fn, ReferenceError, /function throws a reference error/);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3240,
    "codeStart": 3265,
    "code": "assert.throws = function (fn, errt, errs, msg) {\n  if ('string' === typeof errt || errt instanceof RegExp) {\n    errs = errt;\n    errt = null;\n  }\n\n  var assertErr = new Assertion(fn, msg).to.throw(errt, errs);\n  return flag(assertErr, 'object');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "throws",
      "string": "assert.throws()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "doesNotThrow"
      },
      {
        "type": "param",
        "string": "{Function} function",
        "name": "function",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{ErrorConstructor} constructor",
        "name": "constructor",
        "description": "",
        "types": [
          "ErrorConstructor"
        ],
        "typesDescription": "<a href=\"ErrorConstructor.html\">ErrorConstructor</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{RegExp} regexp",
        "name": "regexp",
        "description": "",
        "types": [
          "RegExp"
        ],
        "typesDescription": "<code>RegExp</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "see",
        "string": "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types",
        "title": "",
        "url": "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types"
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .doesNotThrow(function, [constructor/regexp], [message])\n\nAsserts that `function` will _not_ throw an error that is an instance of\n`constructor`, or alternately that it will not throw an error with message\nmatching `regexp`.\n\n    assert.doesNotThrow(fn, Error, 'function does not throw');",
      "summary": "### .doesNotThrow(function, [constructor/regexp], [message])",
      "body": "Asserts that `function` will _not_ throw an error that is an instance of\n`constructor`, or alternately that it will not throw an error with message\nmatching `regexp`.\n\n    assert.doesNotThrow(fn, Error, 'function does not throw');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3275,
    "codeStart": 3294,
    "code": "assert.doesNotThrow = function (fn, type, msg) {\n  if ('string' === typeof type) {\n    msg = type;\n    type = null;\n  }\n\n  new Assertion(fn, msg).to.not.Throw(type);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "doesNotThrow",
      "string": "assert.doesNotThrow()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "operator"
      },
      {
        "type": "param",
        "string": "{Mixed} val1",
        "name": "val1",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} operator",
        "name": "operator",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} val2",
        "name": "val2",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .operator(val1, operator, val2, [message])\n\nCompares two values using `operator`.\n\n    assert.operator(1, '<', 2, 'everything is ok');\n    assert.operator(1, '>', 2, 'this will fail');",
      "summary": "### .operator(val1, operator, val2, [message])",
      "body": "Compares two values using `operator`.\n\n    assert.operator(1, '<', 2, 'everything is ok');\n    assert.operator(1, '>', 2, 'this will fail');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3303,
    "codeStart": 3320,
    "code": "assert.operator = function (val, operator, val2, msg) {\n  var ok;\n  switch(operator) {\n    case '==':\n      ok = val == val2;\n      break;\n    case '===':\n      ok = val === val2;\n      break;\n    case '>':\n      ok = val > val2;\n      break;\n    case '>=':\n      ok = val >= val2;\n      break;\n    case '<':\n      ok = val < val2;\n      break;\n    case '<=':\n      ok = val <= val2;\n      break;\n    case '!=':\n      ok = val != val2;\n      break;\n    case '!==':\n      ok = val !== val2;\n      break;\n    default:\n      throw new Error('Invalid operator \"' + operator + '\"');\n  }\n  var test = new Assertion(ok, msg);\n  test.assert(\n      true === flag(test, 'object')\n    , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)\n    , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "operator",
      "string": "assert.operator()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "closeTo"
      },
      {
        "type": "param",
        "string": "{Number} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} delta",
        "name": "delta",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .closeTo(actual, expected, delta, [message])\n\nAsserts that the target is equal `expected`, to within a +/- `delta` range.\n\n    assert.closeTo(1.5, 1, 0.5, 'numbers are close');",
      "summary": "### .closeTo(actual, expected, delta, [message])",
      "body": "Asserts that the target is equal `expected`, to within a +/- `delta` range.\n\n    assert.closeTo(1.5, 1, 0.5, 'numbers are close');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3357,
    "codeStart": 3373,
    "code": "assert.closeTo = function (act, exp, delta, msg) {\n  new Assertion(act, msg).to.be.closeTo(exp, delta);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "closeTo",
      "string": "assert.closeTo()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "approximately"
      },
      {
        "type": "param",
        "string": "{Number} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} delta",
        "name": "delta",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .approximately(actual, expected, delta, [message])\n\nAsserts that the target is equal `expected`, to within a +/- `delta` range.\n\n    assert.approximately(1.5, 1, 0.5, 'numbers are close');",
      "summary": "### .approximately(actual, expected, delta, [message])",
      "body": "Asserts that the target is equal `expected`, to within a +/- `delta` range.\n\n    assert.approximately(1.5, 1, 0.5, 'numbers are close');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3377,
    "codeStart": 3393,
    "code": "assert.approximately = function (act, exp, delta, msg) {\n  new Assertion(act, msg).to.be.approximately(exp, delta);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "approximately",
      "string": "assert.approximately()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "sameMembers"
      },
      {
        "type": "param",
        "string": "{Array} set1",
        "name": "set1",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} set2",
        "name": "set2",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .sameMembers(set1, set2, [message])\n\nAsserts that `set1` and `set2` have the same members.\nOrder is not taken into account.\n\n    assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');",
      "summary": "### .sameMembers(set1, set2, [message])",
      "body": "Asserts that `set1` and `set2` have the same members.\nOrder is not taken into account.\n\n    assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3397,
    "codeStart": 3413,
    "code": "assert.sameMembers = function (set1, set2, msg) {\n  new Assertion(set1, msg).to.have.same.members(set2);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "sameMembers",
      "string": "assert.sameMembers()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "sameDeepMembers"
      },
      {
        "type": "param",
        "string": "{Array} set1",
        "name": "set1",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} set2",
        "name": "set2",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .sameDeepMembers(set1, set2, [message])\n\nAsserts that `set1` and `set2` have the same members - using a deep equality checking.\nOrder is not taken into account.\n\n    assert.sameDeepMembers([ {b: 3}, {a: 2}, {c: 5} ], [ {c: 5}, {b: 3}, {a: 2} ], 'same deep members');",
      "summary": "### .sameDeepMembers(set1, set2, [message])",
      "body": "Asserts that `set1` and `set2` have the same members - using a deep equality checking.\nOrder is not taken into account.\n\n    assert.sameDeepMembers([ {b: 3}, {a: 2}, {c: 5} ], [ {c: 5}, {b: 3}, {a: 2} ], 'same deep members');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3417,
    "codeStart": 3433,
    "code": "assert.sameDeepMembers = function (set1, set2, msg) {\n  new Assertion(set1, msg).to.have.same.deep.members(set2);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "sameDeepMembers",
      "string": "assert.sameDeepMembers()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "includeMembers"
      },
      {
        "type": "param",
        "string": "{Array} superset",
        "name": "superset",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} subset",
        "name": "subset",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .includeMembers(superset, subset, [message])\n\nAsserts that `subset` is included in `superset`.\nOrder is not taken into account.\n\n    assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');",
      "summary": "### .includeMembers(superset, subset, [message])",
      "body": "Asserts that `subset` is included in `superset`.\nOrder is not taken into account.\n\n    assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3437,
    "codeStart": 3453,
    "code": "assert.includeMembers = function (superset, subset, msg) {\n  new Assertion(superset, msg).to.include.members(subset);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "includeMembers",
      "string": "assert.includeMembers()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "includeDeepMembers"
      },
      {
        "type": "param",
        "string": "{Array} superset",
        "name": "superset",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} subset",
        "name": "subset",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .includeDeepMembers(superset, subset, [message])\n\nAsserts that `subset` is included in `superset` - using deep equality checking.\nOrder is not taken into account.\nDuplicates are ignored.\n\n    assert.includeDeepMembers([ {a: 1}, {b: 2}, {c: 3} ], [ {b: 2}, {a: 1}, {b: 2} ], 'include deep members');",
      "summary": "### .includeDeepMembers(superset, subset, [message])",
      "body": "Asserts that `subset` is included in `superset` - using deep equality checking.\nOrder is not taken into account.\nDuplicates are ignored.\n\n    assert.includeDeepMembers([ {a: 1}, {b: 2}, {c: 3} ], [ {b: 2}, {a: 1}, {b: 2} ], 'include deep members');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3457,
    "codeStart": 3474,
    "code": "assert.includeDeepMembers = function (superset, subset, msg) {\n  new Assertion(superset, msg).to.include.deep.members(subset);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "includeDeepMembers",
      "string": "assert.includeDeepMembers()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "oneOf"
      },
      {
        "type": "param",
        "string": "{*} inList",
        "name": "inList",
        "description": "",
        "types": [],
        "typesDescription": "<code>*</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array<*>} list",
        "name": "list",
        "description": "",
        "types": [
          "Array.<*>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>*</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .oneOf(inList, list, [message])\n\nAsserts that non-object, non-array value `inList` appears in the flat array `list`.\n\n    assert.oneOf(1, [ 2, 1 ], 'Not found in list');",
      "summary": "### .oneOf(inList, list, [message])",
      "body": "Asserts that non-object, non-array value `inList` appears in the flat array `list`.\n\n    assert.oneOf(1, [ 2, 1 ], 'Not found in list');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3478,
    "codeStart": 3493,
    "code": "assert.oneOf = function (inList, list, msg) {\n  new Assertion(inList, msg).to.be.oneOf(list);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "oneOf",
      "string": "assert.oneOf()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "changes"
      },
      {
        "type": "param",
        "string": "{Function} modifier function",
        "name": "modifier",
        "description": "function",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name",
        "name": "property",
        "description": "name",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .changes(function, object, property)\n\nAsserts that a function changes the value of a property\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 22 };\n    assert.changes(fn, obj, 'val');",
      "summary": "### .changes(function, object, property)",
      "body": "Asserts that a function changes the value of a property\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 22 };\n    assert.changes(fn, obj, 'val');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3497,
    "codeStart": 3515,
    "code": "assert.changes = function (fn, obj, prop) {\n  new Assertion(fn).to.change(obj, prop);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "changes",
      "string": "assert.changes()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "doesNotChange"
      },
      {
        "type": "param",
        "string": "{Function} modifier function",
        "name": "modifier",
        "description": "function",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name",
        "name": "property",
        "description": "name",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .doesNotChange(function, object, property)\n\nAsserts that a function does not changes the value of a property\n\n    var obj = { val: 10 };\n    var fn = function() { console.log('foo'); };\n    assert.doesNotChange(fn, obj, 'val');",
      "summary": "### .doesNotChange(function, object, property)",
      "body": "Asserts that a function does not changes the value of a property\n\n    var obj = { val: 10 };\n    var fn = function() { console.log('foo'); };\n    assert.doesNotChange(fn, obj, 'val');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3519,
    "codeStart": 3537,
    "code": "assert.doesNotChange = function (fn, obj, prop) {\n  new Assertion(fn).to.not.change(obj, prop);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "doesNotChange",
      "string": "assert.doesNotChange()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "increases"
      },
      {
        "type": "param",
        "string": "{Function} modifier function",
        "name": "modifier",
        "description": "function",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name",
        "name": "property",
        "description": "name",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .increases(function, object, property)\n\nAsserts that a function increases an object property\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 13 };\n    assert.increases(fn, obj, 'val');",
      "summary": "### .increases(function, object, property)",
      "body": "Asserts that a function increases an object property\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 13 };\n    assert.increases(fn, obj, 'val');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3541,
    "codeStart": 3559,
    "code": "assert.increases = function (fn, obj, prop) {\n  new Assertion(fn).to.increase(obj, prop);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "increases",
      "string": "assert.increases()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "doesNotIncrease"
      },
      {
        "type": "param",
        "string": "{Function} modifier function",
        "name": "modifier",
        "description": "function",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name",
        "name": "property",
        "description": "name",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .doesNotIncrease(function, object, property)\n\nAsserts that a function does not increase object property\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 8 };\n    assert.doesNotIncrease(fn, obj, 'val');",
      "summary": "### .doesNotIncrease(function, object, property)",
      "body": "Asserts that a function does not increase object property\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 8 };\n    assert.doesNotIncrease(fn, obj, 'val');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3563,
    "codeStart": 3581,
    "code": "assert.doesNotIncrease = function (fn, obj, prop) {\n  new Assertion(fn).to.not.increase(obj, prop);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "doesNotIncrease",
      "string": "assert.doesNotIncrease()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "decreases"
      },
      {
        "type": "param",
        "string": "{Function} modifier function",
        "name": "modifier",
        "description": "function",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name",
        "name": "property",
        "description": "name",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .decreases(function, object, property)\n\nAsserts that a function decreases an object property\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 5 };\n    assert.decreases(fn, obj, 'val');",
      "summary": "### .decreases(function, object, property)",
      "body": "Asserts that a function decreases an object property\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 5 };\n    assert.decreases(fn, obj, 'val');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3585,
    "codeStart": 3603,
    "code": "assert.decreases = function (fn, obj, prop) {\n  new Assertion(fn).to.decrease(obj, prop);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "decreases",
      "string": "assert.decreases()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "doesNotDecrease"
      },
      {
        "type": "param",
        "string": "{Function} modifier function",
        "name": "modifier",
        "description": "function",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name",
        "name": "property",
        "description": "name",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .doesNotDecrease(function, object, property)\n\nAsserts that a function does not decreases an object property\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 15 };\n    assert.doesNotDecrease(fn, obj, 'val');",
      "summary": "### .doesNotDecrease(function, object, property)",
      "body": "Asserts that a function does not decreases an object property\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 15 };\n    assert.doesNotDecrease(fn, obj, 'val');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3607,
    "codeStart": 3625,
    "code": "assert.doesNotDecrease = function (fn, obj, prop) {\n  new Assertion(fn).to.not.decrease(obj, prop);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "doesNotDecrease",
      "string": "assert.doesNotDecrease()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "ifError"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .ifError(object)\n\nAsserts if value is not a false value, and throws if it is a true value.\nThis is added to allow for chai to be a drop-in replacement for Node's\nassert class.\n\n    var err = new Error('I am a custom error');\n    assert.ifError(err); // Rethrows err!",
      "summary": "### .ifError(object)",
      "body": "Asserts if value is not a false value, and throws if it is a true value.\nThis is added to allow for chai to be a drop-in replacement for Node's\nassert class.\n\n    var err = new Error('I am a custom error');\n    assert.ifError(err); // Rethrows err!"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 3629,
    "codeStart": 3645,
    "code": "assert.ifError = function (val) {\n  if (val) {\n    throw(val);\n  }\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "ifError",
      "string": "assert.ifError()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isExtensible"
      },
      {
        "type": "alias",
        "string": "extensible"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isExtensible(object)\n\nAsserts that `object` is extensible (can have new properties added to it).\n\n    assert.isExtensible({});",
      "summary": "### .isExtensible(object)",
      "body": "Asserts that `object` is extensible (can have new properties added to it).\n\n    assert.isExtensible({});"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3651,
    "codeStart": 3666,
    "code": "assert.isExtensible = function (obj, msg) {\n  new Assertion(obj, msg).to.be.extensible;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isExtensible",
      "string": "assert.isExtensible()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotExtensible"
      },
      {
        "type": "alias",
        "string": "notExtensible"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotExtensible(object)\n\nAsserts that `object` is _not_ extensible.\n\n    var nonExtensibleObject = Object.preventExtensions({});\n    var sealedObject = Object.seal({});\n    var frozenObject = Object.freese({});\n\n    assert.isNotExtensible(nonExtensibleObject);\n    assert.isNotExtensible(sealedObject);\n    assert.isNotExtensible(frozenObject);",
      "summary": "### .isNotExtensible(object)",
      "body": "Asserts that `object` is _not_ extensible.\n\n    var nonExtensibleObject = Object.preventExtensions({});\n    var sealedObject = Object.seal({});\n    var frozenObject = Object.freese({});\n\n    assert.isNotExtensible(nonExtensibleObject);\n    assert.isNotExtensible(sealedObject);\n    assert.isNotExtensible(frozenObject);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3670,
    "codeStart": 3691,
    "code": "assert.isNotExtensible = function (obj, msg) {\n  new Assertion(obj, msg).to.not.be.extensible;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotExtensible",
      "string": "assert.isNotExtensible()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isSealed"
      },
      {
        "type": "alias",
        "string": "sealed"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isSealed(object)\n\nAsserts that `object` is sealed (cannot have new properties added to it\nand its existing properties cannot be removed).\n\n    var sealedObject = Object.seal({});\n    var frozenObject = Object.seal({});\n\n    assert.isSealed(sealedObject);\n    assert.isSealed(frozenObject);",
      "summary": "### .isSealed(object)",
      "body": "Asserts that `object` is sealed (cannot have new properties added to it\nand its existing properties cannot be removed).\n\n    var sealedObject = Object.seal({});\n    var frozenObject = Object.seal({});\n\n    assert.isSealed(sealedObject);\n    assert.isSealed(frozenObject);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3695,
    "codeStart": 3715,
    "code": "assert.isSealed = function (obj, msg) {\n  new Assertion(obj, msg).to.be.sealed;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isSealed",
      "string": "assert.isSealed()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotSealed"
      },
      {
        "type": "alias",
        "string": "notSealed"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotSealed(object)\n\nAsserts that `object` is _not_ sealed.\n\n    assert.isNotSealed({});",
      "summary": "### .isNotSealed(object)",
      "body": "Asserts that `object` is _not_ sealed.\n\n    assert.isNotSealed({});"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3719,
    "codeStart": 3734,
    "code": "assert.isNotSealed = function (obj, msg) {\n  new Assertion(obj, msg).to.not.be.sealed;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotSealed",
      "string": "assert.isNotSealed()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isFrozen"
      },
      {
        "type": "alias",
        "string": "frozen"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isFrozen(object)\n\nAsserts that `object` is frozen (cannot have new properties added to it\nand its existing properties cannot be modified).\n\n    var frozenObject = Object.freeze({});\n    assert.frozen(frozenObject);",
      "summary": "### .isFrozen(object)",
      "body": "Asserts that `object` is frozen (cannot have new properties added to it\nand its existing properties cannot be modified).\n\n    var frozenObject = Object.freeze({});\n    assert.frozen(frozenObject);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3738,
    "codeStart": 3755,
    "code": "assert.isFrozen = function (obj, msg) {\n  new Assertion(obj, msg).to.be.frozen;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isFrozen",
      "string": "assert.isFrozen()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotFrozen"
      },
      {
        "type": "alias",
        "string": "notFrozen"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotFrozen(object)\n\nAsserts that `object` is _not_ frozen.\n\n    assert.isNotFrozen({});",
      "summary": "### .isNotFrozen(object)",
      "body": "Asserts that `object` is _not_ frozen.\n\n    assert.isNotFrozen({});"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3759,
    "codeStart": 3774,
    "code": "assert.isNotFrozen = function (obj, msg) {\n  new Assertion(obj, msg).to.not.be.frozen;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotFrozen",
      "string": "assert.isNotFrozen()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Aliases.",
      "summary": "Aliases.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 3778,
    "codeStart": 3782,
    "code": "(function alias(name, as){\n  assert[as] = assert[name];\n  return alias;\n})\n('isOk', 'ok')\n('isNotOk', 'notOk')\n('throws', 'throw')\n('throws', 'Throw')\n('isExtensible', 'extensible')\n('isNotExtensible', 'notExtensible')\n('isSealed', 'sealed')\n('isNotSealed', 'notSealed')\n('isFrozen', 'frozen')\n('isNotFrozen', 'notFrozen');\n};\n\n},{}],7:[function(require,module,exports){",
    "ctx": false
  },
  {
    "tags": [],
    "description": {
      "full": "chai\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "chai\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 3799,
    "codeStart": 3805,
    "code": "module.exports = function (chai, util) {\n  chai.expect = function (val, message) {\n    return new chai.Assertion(val, message);\n  };",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "fail"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} operator",
        "name": "operator",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Expect"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .fail(actual, expected, [message], [operator])\n\nThrow a failure.",
      "summary": "### .fail(actual, expected, [message], [operator])",
      "body": "Throw a failure."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3810,
    "codeStart": 3824,
    "code": "chai.expect.fail = function (actual, expected, message, operator) {\n  message = message || 'expect.fail()';\n  throw new chai.AssertionError(message, {\n      actual: actual\n    , expected: expected\n    , operator: operator\n  }, chai.expect.fail);\n};\n};\n\n},{}],8:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "chai.expect",
      "name": "fail",
      "string": "chai.expect.fail()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "chai\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "chai\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 3835,
    "codeStart": 3841,
    "code": "module.exports = function (chai, util) {\n  var Assertion = chai.Assertion;\n\n  function loadShould () {\n    // explicitly define this method as function as to have it's name to include as `ssfi`\n    function shouldGetter() {\n      if (this instanceof String || this instanceof Number || this instanceof Boolean ) {\n        return new Assertion(this.valueOf(), null, shouldGetter);\n      }\n      return new Assertion(this, null, shouldGetter);\n    }\n    function shouldSetter(value) {\n      // See https://github.com/chaijs/chai/issues/86: this makes\n      // `whatever.should = someValue` actually set `someValue`, which is\n      // especially useful for `global.should = require('chai').should()`.\n      //\n      // Note that we have to use [[DefineProperty]] instead of [[Put]]\n      // since otherwise we would trigger this very setter!\n      Object.defineProperty(this, 'should', {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    }\n    // modify Object.prototype to have `should`\n    Object.defineProperty(Object.prototype, 'should', {\n      set: shouldSetter\n      , get: shouldGetter\n      , configurable: true\n    });\n\n    var should = {};",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "fail"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} operator",
        "name": "operator",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Should"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .fail(actual, expected, [message], [operator])\n\nThrow a failure.",
      "summary": "### .fail(actual, expected, [message], [operator])",
      "body": "Throw a failure."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3875,
    "codeStart": 3889,
    "code": "should.fail = function (actual, expected, message, operator) {\n  message = message || 'should.fail()';\n  throw new chai.AssertionError(message, {\n      actual: actual\n    , expected: expected\n    , operator: operator\n  }, should.fail);\n};",
    "ctx": {
      "type": "method",
      "receiver": "should",
      "name": "fail",
      "string": "should.fail()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "equal"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Should"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .equal(actual, expected, [message])\n\nAsserts non-strict equality (`==`) of `actual` and `expected`.\n\n    should.equal(3, '3', '== coerces values to strings');",
      "summary": "### .equal(actual, expected, [message])",
      "body": "Asserts non-strict equality (`==`) of `actual` and `expected`.\n\n    should.equal(3, '3', '== coerces values to strings');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3898,
    "codeStart": 3913,
    "code": "should.equal = function (val1, val2, msg) {\n  new Assertion(val1, msg).to.equal(val2);\n};",
    "ctx": {
      "type": "method",
      "receiver": "should",
      "name": "equal",
      "string": "should.equal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "throw"
      },
      {
        "type": "alias",
        "string": "Throw"
      },
      {
        "type": "param",
        "string": "{Function} function",
        "name": "function",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{ErrorConstructor} constructor",
        "name": "constructor",
        "description": "",
        "types": [
          "ErrorConstructor"
        ],
        "typesDescription": "<a href=\"ErrorConstructor.html\">ErrorConstructor</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{RegExp} regexp",
        "name": "regexp",
        "description": "",
        "types": [
          "RegExp"
        ],
        "typesDescription": "<code>RegExp</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "see",
        "string": "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types",
        "title": "",
        "url": "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types"
      },
      {
        "type": "namespace",
        "string": "Should"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .throw(function, [constructor/string/regexp], [string/regexp], [message])\n\nAsserts that `function` will throw an error that is an instance of\n`constructor`, or alternately that it will throw an error with message\nmatching `regexp`.\n\n    should.throw(fn, 'function throws a reference error');\n    should.throw(fn, /function throws a reference error/);\n    should.throw(fn, ReferenceError);\n    should.throw(fn, ReferenceError, 'function throws a reference error');\n    should.throw(fn, ReferenceError, /function throws a reference error/);",
      "summary": "### .throw(function, [constructor/string/regexp], [string/regexp], [message])",
      "body": "Asserts that `function` will throw an error that is an instance of\n`constructor`, or alternately that it will throw an error with message\nmatching `regexp`.\n\n    should.throw(fn, 'function throws a reference error');\n    should.throw(fn, /function throws a reference error/);\n    should.throw(fn, ReferenceError);\n    should.throw(fn, ReferenceError, 'function throws a reference error');\n    should.throw(fn, ReferenceError, /function throws a reference error/);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3917,
    "codeStart": 3941,
    "code": "should.Throw = function (fn, errt, errs, msg) {\n  new Assertion(fn, msg).to.Throw(errt, errs);\n};",
    "ctx": {
      "type": "method",
      "receiver": "should",
      "name": "Throw",
      "string": "should.Throw()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "exist"
      },
      {
        "type": "namespace",
        "string": "Should"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .exist\n\nAsserts that the target is neither `null` nor `undefined`.\n\n    var foo = 'hi';\n\n    should.exist(foo, 'foo exists');",
      "summary": "### .exist",
      "body": "Asserts that the target is neither `null` nor `undefined`.\n\n    var foo = 'hi';\n\n    should.exist(foo, 'foo exists');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3945,
    "codeStart": 3959,
    "code": "should.exist = function (val, msg) {\n  new Assertion(val, msg).to.exist;\n}\n\n// negation\nshould.not = {}",
    "ctx": {
      "type": "method",
      "receiver": "should",
      "name": "exist",
      "string": "should.exist()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "not.equal"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Should"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .not.equal(actual, expected, [message])\n\nAsserts non-strict inequality (`!=`) of `actual` and `expected`.\n\n    should.not.equal(3, 4, 'these numbers are not equal');",
      "summary": "### .not.equal(actual, expected, [message])",
      "body": "Asserts non-strict inequality (`!=`) of `actual` and `expected`.\n\n    should.not.equal(3, 4, 'these numbers are not equal');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3966,
    "codeStart": 3981,
    "code": "should.not.equal = function (val1, val2, msg) {\n  new Assertion(val1, msg).to.not.equal(val2);\n};",
    "ctx": {
      "type": "method",
      "receiver": "should.not",
      "name": "equal",
      "string": "should.not.equal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "not.throw"
      },
      {
        "type": "alias",
        "string": "not.Throw"
      },
      {
        "type": "param",
        "string": "{Function} function",
        "name": "function",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{ErrorConstructor} constructor",
        "name": "constructor",
        "description": "",
        "types": [
          "ErrorConstructor"
        ],
        "typesDescription": "<a href=\"ErrorConstructor.html\">ErrorConstructor</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{RegExp} regexp",
        "name": "regexp",
        "description": "",
        "types": [
          "RegExp"
        ],
        "typesDescription": "<code>RegExp</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "see",
        "string": "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types",
        "title": "",
        "url": "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types"
      },
      {
        "type": "namespace",
        "string": "Should"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .throw(function, [constructor/regexp], [message])\n\nAsserts that `function` will _not_ throw an error that is an instance of\n`constructor`, or alternately that it will not throw an error with message\nmatching `regexp`.\n\n    should.not.throw(fn, Error, 'function does not throw');",
      "summary": "### .throw(function, [constructor/regexp], [message])",
      "body": "Asserts that `function` will _not_ throw an error that is an instance of\n`constructor`, or alternately that it will not throw an error with message\nmatching `regexp`.\n\n    should.not.throw(fn, Error, 'function does not throw');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3985,
    "codeStart": 4005,
    "code": "should.not.Throw = function (fn, errt, errs, msg) {\n  new Assertion(fn, msg).to.not.Throw(errt, errs);\n};",
    "ctx": {
      "type": "method",
      "receiver": "should.not",
      "name": "Throw",
      "string": "should.not.Throw()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "not.exist"
      },
      {
        "type": "namespace",
        "string": "Should"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .not.exist\n\nAsserts that the target is neither `null` nor `undefined`.\n\n    var bar = null;\n\n    should.not.exist(bar, 'bar does not exist');",
      "summary": "### .not.exist",
      "body": "Asserts that the target is neither `null` nor `undefined`.\n\n    var bar = null;\n\n    should.not.exist(bar, 'bar does not exist');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4009,
    "codeStart": 4023,
    "code": "should.not.exist = function (val, msg) {\n  new Assertion(val, msg).to.not.exist;\n}\n\nshould['throw'] = should['Throw'];\nshould.not['throw'] = should.not['Throw'];\n\nreturn should;\n  };\n\n  chai.should = loadShould;\n  chai.Should = loadShould;\n};\n\n},{}],9:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "should.not",
      "name": "exist",
      "string": "should.not.exist()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - addChainingMethod utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - addChainingMethod utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4038,
    "codeStart": 4043
  },
  {
    "tags": [],
    "description": {
      "full": "Module dependencies",
      "summary": "Module dependencies",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4044,
    "codeStart": 4048,
    "code": "var transferFlags = require('./transferFlags');\nvar flag = require('./flag');\nvar config = require('../config');",
    "ctx": {
      "type": "declaration",
      "name": "transferFlags",
      "value": "require('./transferFlags')",
      "string": "transferFlags"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Module variables",
      "summary": "Module variables",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4052,
    "codeStart": 4056,
    "code": "// Check whether `__proto__` is supported\nvar hasProtoSupport = '__proto__' in Object;\n\n// Without `__proto__` support, this module will need to add properties to a function.\n// However, some Function.prototype methods cannot be overwritten,\n// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).\nvar excludeNames = /^(?:length|name|arguments|caller)$/;\n\n// Cache `Function` properties\nvar call  = Function.prototype.call,\n    apply = Function.prototype.apply;",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} ctx object to which the method is added",
        "name": "ctx",
        "description": "object to which the method is added",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} name of method to add",
        "name": "name",
        "description": "of method to add",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Function} method function to be used for `name`, when called",
        "name": "method",
        "description": "function to be used for `name`, when called",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Function} chainingBehavior function to be called every time the property is accessed",
        "name": "chainingBehavior",
        "description": "function to be called every time the property is accessed",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "addChainableMethod"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### addChainableMethod (ctx, name, method, chainingBehavior)\n\nAdds a method to an object, such that the method can also be chained.\n\n    utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {\n      var obj = utils.flag(this, 'object');\n      new chai.Assertion(obj).to.be.equal(str);\n    });\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);\n\nThe result can then be used as both a method assertion, executing both `method` and\n`chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.\n\n    expect(fooStr).to.be.foo('bar');\n    expect(fooStr).to.be.foo.equal('foo');",
      "summary": "### addChainableMethod (ctx, name, method, chainingBehavior)",
      "body": "Adds a method to an object, such that the method can also be chained.\n\n    utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {\n      var obj = utils.flag(this, 'object');\n      new chai.Assertion(obj).to.be.equal(str);\n    });\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);\n\nThe result can then be used as both a method assertion, executing both `method` and\n`chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.\n\n    expect(fooStr).to.be.foo('bar');\n    expect(fooStr).to.be.foo.equal('foo');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4068,
    "codeStart": 4097,
    "code": "module.exports = function (ctx, name, method, chainingBehavior) {\n  if (typeof chainingBehavior !== 'function') {\n    chainingBehavior = function () { };\n  }\n\n  var chainableBehavior = {\n      method: method\n    , chainingBehavior: chainingBehavior\n  };\n\n  // save the methods so we can overwrite them later, if we need to.\n  if (!ctx.__methods) {\n    ctx.__methods = {};\n  }\n  ctx.__methods[name] = chainableBehavior;\n\n  Object.defineProperty(ctx, name,\n    { get: function () {\n        chainableBehavior.chainingBehavior.call(this);\n\n        var assert = function assert() {\n          var old_ssfi = flag(this, 'ssfi');\n          if (old_ssfi && config.includeStack === false)\n            flag(this, 'ssfi', assert);\n          var result = chainableBehavior.method.apply(this, arguments);\n          return result === undefined ? this : result;\n        };\n\n        // Use `__proto__` if available\n        if (hasProtoSupport) {\n          // Inherit all properties from the object by replacing the `Function` prototype\n          var prototype = assert.__proto__ = Object.create(this);\n          // Restore the `call` and `apply` methods from `Function`\n          prototype.call = call;\n          prototype.apply = apply;\n        }\n        // Otherwise, redefine all properties (slow!)\n        else {\n          var asserterNames = Object.getOwnPropertyNames(ctx);\n          asserterNames.forEach(function (asserterName) {\n            if (!excludeNames.test(asserterName)) {\n              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);\n              Object.defineProperty(assert, asserterName, pd);\n            }\n          });\n        }\n\n        transferFlags(this, assert);\n        return assert;\n      }\n    , configurable: true\n  });\n};\n\n},{\"../config\":4,\"./flag\":13,\"./transferFlags\":29}],10:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - addMethod utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - addMethod utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4152,
    "codeStart": 4158,
    "code": "var config = require('../config');",
    "ctx": {
      "type": "declaration",
      "name": "config",
      "value": "require('../config')",
      "string": "config"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} ctx object to which the method is added",
        "name": "ctx",
        "description": "object to which the method is added",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} name of method to add",
        "name": "name",
        "description": "of method to add",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Function} method function to be used for name",
        "name": "method",
        "description": "function to be used for name",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "addMethod"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .addMethod (ctx, name, method)\n\nAdds a method to the prototype of an object.\n\n    utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {\n      var obj = utils.flag(this, 'object');\n      new chai.Assertion(obj).to.be.equal(str);\n    });\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.addMethod('foo', fn);\n\nThen can be used as any other assertion.\n\n    expect(fooStr).to.be.foo('bar');",
      "summary": "### .addMethod (ctx, name, method)",
      "body": "Adds a method to the prototype of an object.\n\n    utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {\n      var obj = utils.flag(this, 'object');\n      new chai.Assertion(obj).to.be.equal(str);\n    });\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.addMethod('foo', fn);\n\nThen can be used as any other assertion.\n\n    expect(fooStr).to.be.foo('bar');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4160,
    "codeStart": 4185,
    "code": "var flag = require('./flag');\n\nmodule.exports = function (ctx, name, method) {\n  ctx[name] = function () {\n    var old_ssfi = flag(this, 'ssfi');\n    if (old_ssfi && config.includeStack === false)\n      flag(this, 'ssfi', ctx[name]);\n    var result = method.apply(this, arguments);\n    return result === undefined ? this : result;\n  };\n};\n\n},{\"../config\":4,\"./flag\":13}],11:[function(require,module,exports){",
    "ctx": {
      "type": "declaration",
      "name": "flag",
      "value": "require('./flag')",
      "string": "flag"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - addProperty utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - addProperty utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4198,
    "codeStart": 4204,
    "code": "var config = require('../config');\nvar flag = require('./flag');",
    "ctx": {
      "type": "declaration",
      "name": "config",
      "value": "require('../config')",
      "string": "config"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} ctx object to which the property is added",
        "name": "ctx",
        "description": "object to which the property is added",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} name of property to add",
        "name": "name",
        "description": "of property to add",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Function} getter function to be used for name",
        "name": "getter",
        "description": "function to be used for name",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "addProperty"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### addProperty (ctx, name, getter)\n\nAdds a property to the prototype of an object.\n\n    utils.addProperty(chai.Assertion.prototype, 'foo', function () {\n      var obj = utils.flag(this, 'object');\n      new chai.Assertion(obj).to.be.instanceof(Foo);\n    });\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.addProperty('foo', fn);\n\nThen can be used as any other assertion.\n\n    expect(myFoo).to.be.foo;",
      "summary": "### addProperty (ctx, name, getter)",
      "body": "Adds a property to the prototype of an object.\n\n    utils.addProperty(chai.Assertion.prototype, 'foo', function () {\n      var obj = utils.flag(this, 'object');\n      new chai.Assertion(obj).to.be.instanceof(Foo);\n    });\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.addProperty('foo', fn);\n\nThen can be used as any other assertion.\n\n    expect(myFoo).to.be.foo;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4207,
    "codeStart": 4233,
    "code": "module.exports = function (ctx, name, getter) {\n  Object.defineProperty(ctx, name,\n    { get: function addProperty() {\n        var old_ssfi = flag(this, 'ssfi');\n        if (old_ssfi && config.includeStack === false)\n          flag(this, 'ssfi', addProperty);\n\n        var result = getter.call(this);\n        return result === undefined ? this : result;\n      }\n    , configurable: true\n  });\n};\n\n},{\"../config\":4,\"./flag\":13}],12:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - expectTypes utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - expectTypes utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4248,
    "codeStart": 4253
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} obj constructed Assertion",
        "name": "obj",
        "description": "constructed Assertion",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} type A list of allowed types for this assertion",
        "name": "type",
        "description": "A list of allowed types for this assertion",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "expectTypes"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### expectTypes(obj, types)\n\nEnsures that the object being tested against is of a valid type.\n\n    utils.expectTypes(this, ['array', 'object', 'string']);",
      "summary": "### expectTypes(obj, types)",
      "body": "Ensures that the object being tested against is of a valid type.\n\n    utils.expectTypes(this, ['array', 'object', 'string']);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4254,
    "codeStart": 4268,
    "code": "var AssertionError = require('assertion-error');\nvar flag = require('./flag');\nvar type = require('type-detect');\n\nmodule.exports = function (obj, types) {\n  var obj = flag(obj, 'object');\n  types = types.map(function (t) { return t.toLowerCase(); });\n  types.sort();\n\n  // Transforms ['lorem', 'ipsum'] into 'a lirum, or an ipsum'\n  var str = types.map(function (t, index) {\n    var art = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(t.charAt(0)) ? 'an' : 'a';\n    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';\n    return or + art + ' ' + t;\n  }).join(', ');\n\n  if (!types.some(function (expected) { return type(obj) === expected; })) {\n    throw new AssertionError(\n      'object tested must be ' + str + ', but ' + type(obj) + ' given'\n    );\n  }\n};\n\n},{\"./flag\":13,\"assertion-error\":30,\"type-detect\":35}],13:[function(require,module,exports){",
    "ctx": {
      "type": "declaration",
      "name": "AssertionError",
      "value": "require('assertion-error')",
      "string": "AssertionError"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - flag utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - flag utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4292,
    "codeStart": 4297
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} object constructed Assertion",
        "name": "object",
        "description": "constructed Assertion",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} key",
        "name": "key",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} value (optional)",
        "name": "value",
        "description": "(optional)",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "flag"
      },
      {
        "type": "api",
        "string": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "### flag(object, key, [value])\n\nGet or set a flag value on an object. If a\nvalue is provided it will be set, else it will\nreturn the currently set value or `undefined` if\nthe value is not set.\n\n    utils.flag(this, 'foo', 'bar'); // setter\n    utils.flag(this, 'foo'); // getter, returns `bar`",
      "summary": "### flag(object, key, [value])",
      "body": "Get or set a flag value on an object. If a\nvalue is provided it will be set, else it will\nreturn the currently set value or `undefined` if\nthe value is not set.\n\n    utils.flag(this, 'foo', 'bar'); // setter\n    utils.flag(this, 'foo'); // getter, returns `bar`"
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4298,
    "codeStart": 4317,
    "code": "module.exports = function (obj, key, value) {\n  var flags = obj.__flags || (obj.__flags = Object.create(null));\n  if (arguments.length === 3) {\n    flags[key] = value;\n  } else {\n    return flags[key];\n  }\n};\n\n},{}],14:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - getActual utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - getActual utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4327,
    "codeStart": 4332
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} object (constructed Assertion)",
        "name": "object",
        "description": "(constructed Assertion)",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Arguments} chai.Assertion.prototype.assert arguments",
        "name": "chai.Assertion.prototype.assert",
        "description": "arguments",
        "types": [
          "Arguments"
        ],
        "typesDescription": "<a href=\"Arguments.html\">Arguments</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "getActual"
      }
    ],
    "description": {
      "full": "# getActual(object, [actual])\n\nReturns the `actual` value for an Assertion",
      "summary": "# getActual(object, [actual])",
      "body": "Returns the `actual` value for an Assertion"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4333,
    "codeStart": 4344,
    "code": "module.exports = function (obj, args) {\n  return args.length > 4 ? args[4] : obj._obj;\n};\n\n},{}],15:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - getEnumerableProperties utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - getEnumerableProperties utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4349,
    "codeStart": 4354
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Array}",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": ""
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "getEnumerableProperties"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .getEnumerableProperties(object)\n\nThis allows the retrieval of enumerable property names of an object,\ninherited or not.",
      "summary": "### .getEnumerableProperties(object)",
      "body": "This allows the retrieval of enumerable property names of an object,\ninherited or not."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4355,
    "codeStart": 4368,
    "code": "module.exports = function getEnumerableProperties(object) {\n  var result = [];\n  for (var name in object) {\n    result.push(name);\n  }\n  return result;\n};\n\n},{}],16:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - message composition utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - message composition utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4377,
    "codeStart": 4382
  },
  {
    "tags": [],
    "description": {
      "full": "Module dependancies",
      "summary": "Module dependancies",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4383,
    "codeStart": 4387,
    "code": "var flag = require('./flag')\n  , getActual = require('./getActual')\n  , inspect = require('./inspect')\n  , objDisplay = require('./objDisplay');",
    "ctx": {
      "type": "declaration",
      "name": "flag",
      "value": "require('./flag')",
      "string": "flag"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} object (constructed Assertion)",
        "name": "object",
        "description": "(constructed Assertion)",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Arguments} chai.Assertion.prototype.assert arguments",
        "name": "chai.Assertion.prototype.assert",
        "description": "arguments",
        "types": [
          "Arguments"
        ],
        "typesDescription": "<a href=\"Arguments.html\">Arguments</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "getMessage"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .getMessage(object, message, negateMessage)\n\nConstruct the error message based on flags\nand template tags. Template tags will return\na stringified inspection of the object referenced.\n\nMessage template tags:\n- `#{this}` current asserted object\n- `#{act}` actual value\n- `#{exp}` expected value",
      "summary": "### .getMessage(object, message, negateMessage)",
      "body": "Construct the error message based on flags\nand template tags. Template tags will return\na stringified inspection of the object referenced.\n\nMessage template tags:\n- `#{this}` current asserted object\n- `#{act}` actual value\n- `#{exp}` expected value"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4392,
    "codeStart": 4411,
    "code": "module.exports = function (obj, args) {\n  var negate = flag(obj, 'negate')\n    , val = flag(obj, 'object')\n    , expected = args[3]\n    , actual = getActual(obj, args)\n    , msg = negate ? args[2] : args[1]\n    , flagMsg = flag(obj, 'message');\n\n  if(typeof msg === \"function\") msg = msg();\n  msg = msg || '';\n  msg = msg\n    .replace(/#\\{this\\}/g, function () { return objDisplay(val); })\n    .replace(/#\\{act\\}/g, function () { return objDisplay(actual); })\n    .replace(/#\\{exp\\}/g, function () { return objDisplay(expected); });\n\n  return flagMsg ? flagMsg + ': ' + msg : msg;\n};\n\n},{\"./flag\":13,\"./getActual\":14,\"./inspect\":23,\"./objDisplay\":24}],17:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - getName utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - getName utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4430,
    "codeStart": 4435
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Function} a function (usually a constructor)",
        "name": "a",
        "description": "function (usually a constructor)",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "getName"
      }
    ],
    "description": {
      "full": "# getName(func)\n\nGets the name of a function, in a cross-browser way.",
      "summary": "# getName(func)",
      "body": "Gets the name of a function, in a cross-browser way."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4436,
    "codeStart": 4446,
    "code": "module.exports = function (func) {\n  if (func.name) return func.name;\n\n  var match = /^\\s?function ([^(]*)\\(/.exec(func);\n  return match && match[1] ? match[1] : \"\";\n};\n\n},{}],18:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - getPathInfo utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - getPathInfo utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4454,
    "codeStart": 4460,
    "code": "var hasProperty = require('./hasProperty');",
    "ctx": {
      "type": "declaration",
      "name": "hasProperty",
      "value": "require('./hasProperty')",
      "string": "hasProperty"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{String} path",
        "name": "path",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Object} info",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "info"
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "getPathInfo"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .getPathInfo(path, object)\n\nThis allows the retrieval of property info in an\nobject given a string path.\n\nThe path info consists of an object with the\nfollowing properties:\n\n* parent - The parent object of the property referenced by `path`\n* name - The name of the final property, a number if it was an array indexer\n* value - The value of the property, if it exists, otherwise `undefined`\n* exists - Whether the property exists or not",
      "summary": "### .getPathInfo(path, object)",
      "body": "This allows the retrieval of property info in an\nobject given a string path.\n\nThe path info consists of an object with the\nfollowing properties:\n\n* parent - The parent object of the property referenced by `path`\n* name - The name of the final property, a number if it was an array indexer\n* value - The value of the property, if it exists, otherwise `undefined`\n* exists - Whether the property exists or not"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4462,
    "codeStart": 4484,
    "code": "module.exports = function getPathInfo(path, obj) {\n  var parsed = parsePath(path),\n      last = parsed[parsed.length - 1];\n\n  var info = {\n    parent: parsed.length > 1 ? _getPathValue(parsed, obj, parsed.length - 1) : obj,\n    name: last.p || last.i,\n    value: _getPathValue(parsed, obj)\n  };\n  info.exists = hasProperty(info.name, info.parent);\n\n  return info;\n};",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{String} path",
        "name": "path",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Object} parsed",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "parsed"
      },
      {
        "type": "api",
        "string": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "## parsePath(path)\n\nHelper function used to parse string object\npaths. Use in conjunction with `_getPathValue`.\n\n     var parsed = parsePath('myobject.property.subprop');\n\n### Paths:\n\n* Can be as near infinitely deep and nested\n* Arrays are also valid using the formal `myobject.document[3].property`.\n* Literal dots and brackets (not delimiter) must be backslash-escaped.",
      "summary": "## parsePath(path)",
      "body": "Helper function used to parse string object\npaths. Use in conjunction with `_getPathValue`.\n\n     var parsed = parsePath('myobject.property.subprop');\n\n### Paths:\n\n* Can be as near infinitely deep and nested\n* Arrays are also valid using the formal `myobject.document[3].property`.\n* Literal dots and brackets (not delimiter) must be backslash-escaped."
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4499,
    "codeStart": 4518,
    "code": "function parsePath (path) {\n  var str = path.replace(/([^\\\\])\\[/g, '$1.[')\n    , parts = str.match(/(\\\\\\.|[^.]+?)+/g);\n  return parts.map(function (value) {\n    var re = /^\\[(\\d+)\\]$/\n      , mArr = re.exec(value);\n    if (mArr) return { i: parseFloat(mArr[1]) };\n    else return { p: value.replace(/\\\\([.\\[\\]])/g, '$1') };\n  });\n}",
    "ctx": {
      "type": "function",
      "name": "parsePath",
      "string": "parsePath()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} parsed definition from `parsePath`.",
        "name": "parsed",
        "description": "definition from `parsePath`.",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object to search against",
        "name": "object",
        "description": "to search against",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} object to search against",
        "name": "object",
        "description": "to search against",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Object|Undefined} value",
        "types": [
          "Object",
          "Undefined"
        ],
        "typesDescription": "<code>Object</code>|<code>Undefined</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "value"
      },
      {
        "type": "api",
        "string": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "## _getPathValue(parsed, obj)\n\nHelper companion function for `.parsePath` that returns\nthe value located at the parsed address.\n\n     var value = getPathValue(parsed, obj);",
      "summary": "## _getPathValue(parsed, obj)",
      "body": "Helper companion function for `.parsePath` that returns\nthe value located at the parsed address.\n\n     var value = getPathValue(parsed, obj);"
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4530,
    "codeStart": 4545,
    "code": "function _getPathValue (parsed, obj, index) {\n  var tmp = obj\n    , res;\n\n  index = (index === undefined ? parsed.length : index);\n\n  for (var i = 0, l = index; i < l; i++) {\n    var part = parsed[i];\n    if (tmp) {\n      if ('undefined' !== typeof part.p)\n        tmp = tmp[part.p];\n      else if ('undefined' !== typeof part.i)\n        tmp = tmp[part.i];\n      if (i == (l - 1)) res = tmp;\n    } else {\n      res = undefined;\n    }\n  }\n  return res;\n}\n\n},{\"./hasProperty\":21}],19:[function(require,module,exports){",
    "ctx": {
      "type": "function",
      "name": "_getPathValue",
      "string": "_getPathValue()"
    }
  },
  {
    "tags": [
      {
        "type": "see",
        "string": "https://github.com/logicalparadox/filtr\nMIT Licensed",
        "title": "https://github.com/logicalparadox/filtr",
        "url": "MIT Licensed"
      }
    ],
    "description": {
      "full": "Chai - getPathValue utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>",
      "summary": "Chai - getPathValue utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4567,
    "codeStart": 4574,
    "code": "var getPathInfo = require('./getPathInfo');",
    "ctx": {
      "type": "declaration",
      "name": "getPathInfo",
      "value": "require('./getPathInfo')",
      "string": "getPathInfo"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{String} path",
        "name": "path",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Object} value or `undefined`",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "value or `undefined`"
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "getPathValue"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .getPathValue(path, object)\n\nThis allows the retrieval of values in an\nobject given a string path.\n\n    var obj = {\n        prop1: {\n            arr: ['a', 'b', 'c']\n          , str: 'Hello'\n        }\n      , prop2: {\n            arr: [ { nested: 'Universe' } ]\n          , str: 'Hello again!'\n        }\n    }\n\nThe following would be the results.\n\n    getPathValue('prop1.str', obj); // Hello\n    getPathValue('prop1.att[2]', obj); // b\n    getPathValue('prop2.arr[0].nested', obj); // Universe",
      "summary": "### .getPathValue(path, object)",
      "body": "This allows the retrieval of values in an\nobject given a string path.\n\n    var obj = {\n        prop1: {\n            arr: ['a', 'b', 'c']\n          , str: 'Hello'\n        }\n      , prop2: {\n            arr: [ { nested: 'Universe' } ]\n          , str: 'Hello again!'\n        }\n    }\n\nThe following would be the results.\n\n    getPathValue('prop1.str', obj); // Hello\n    getPathValue('prop1.att[2]', obj); // b\n    getPathValue('prop2.arr[0].nested', obj); // Universe"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4576,
    "codeStart": 4606,
    "code": "module.exports = function(path, obj) {\n  var info = getPathInfo(path, obj);\n  return info.value;\n};\n\n},{\"./getPathInfo\":18}],20:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - getProperties utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - getProperties utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4612,
    "codeStart": 4617
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Array}",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": ""
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "getProperties"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .getProperties(object)\n\nThis allows the retrieval of property names of an object, enumerable or not,\ninherited or not.",
      "summary": "### .getProperties(object)",
      "body": "This allows the retrieval of property names of an object, enumerable or not,\ninherited or not."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4618,
    "codeStart": 4631,
    "code": "module.exports = function getProperties(object) {\n  var result = Object.getOwnPropertyNames(object);\n\n  function addProperty(property) {\n    if (result.indexOf(property) === -1) {\n      result.push(property);\n    }\n  }\n\n  var proto = Object.getPrototypeOf(object);\n  while (proto !== null) {\n    Object.getOwnPropertyNames(proto).forEach(addProperty);\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return result;\n};\n\n},{}],21:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - hasProperty utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - hasProperty utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4650,
    "codeStart": 4656,
    "code": "var type = require('type-detect');",
    "ctx": {
      "type": "declaration",
      "name": "type",
      "value": "require('type-detect')",
      "string": "type"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Objuect} object",
        "name": "object",
        "description": "",
        "types": [
          "Objuect"
        ],
        "typesDescription": "<a href=\"Objuect.html\">Objuect</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String|Number} name",
        "name": "name",
        "description": "",
        "types": [
          "String",
          "Number"
        ],
        "typesDescription": "<code>String</code>|<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Boolean} whether it exists",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "whether it exists"
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "getPathInfo"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .hasProperty(object, name)\n\nThis allows checking whether an object has\nnamed property or numeric array index.\n\nBasically does the same thing as the `in`\noperator but works properly with natives\nand null/undefined values.\n\n    var obj = {\n        arr: ['a', 'b', 'c']\n      , str: 'Hello'\n    }\n\nThe following would be the results.\n\n    hasProperty('str', obj);  // true\n    hasProperty('constructor', obj);  // true\n    hasProperty('bar', obj);  // false\n\n    hasProperty('length', obj.str); // true\n    hasProperty(1, obj.str);  // true\n    hasProperty(5, obj.str);  // false\n\n    hasProperty('length', obj.arr);  // true\n    hasProperty(2, obj.arr);  // true\n    hasProperty(3, obj.arr);  // false",
      "summary": "### .hasProperty(object, name)",
      "body": "This allows checking whether an object has\nnamed property or numeric array index.\n\nBasically does the same thing as the `in`\noperator but works properly with natives\nand null/undefined values.\n\n    var obj = {\n        arr: ['a', 'b', 'c']\n      , str: 'Hello'\n    }\n\nThe following would be the results.\n\n    hasProperty('str', obj);  // true\n    hasProperty('constructor', obj);  // true\n    hasProperty('bar', obj);  // false\n\n    hasProperty('length', obj.str); // true\n    hasProperty(1, obj.str);  // true\n    hasProperty(5, obj.str);  // false\n\n    hasProperty('length', obj.arr);  // true\n    hasProperty(2, obj.arr);  // true\n    hasProperty(3, obj.arr);  // false"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4658,
    "codeStart": 4695,
    "code": "var literals = {\n    'number': Number\n  , 'string': String\n};\n\nmodule.exports = function hasProperty(name, obj) {\n  var ot = type(obj);\n\n  // Bad Object, obviously no props at all\n  if(ot === 'null' || ot === 'undefined')\n    return false;\n\n  // The `in` operator does not work with certain literals\n  // box these before the check\n  if(literals[ot] && typeof obj !== 'object')\n    obj = new literals[ot](obj);\n\n  return name in obj;\n};\n\n},{\"type-detect\":35}],22:[function(require,module,exports){",
    "ctx": {
      "type": "declaration",
      "name": "literals",
      "value": "{",
      "string": "literals"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "chai\nCopyright(c) 2011 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "chai\nCopyright(c) 2011 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4716,
    "codeStart": 4721
  },
  {
    "tags": [],
    "description": {
      "full": "Main exports",
      "summary": "Main exports",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4722,
    "codeStart": 4726,
    "code": "var exports = module.exports = {};",
    "ctx": {
      "type": "declaration",
      "name": "exports",
      "value": "module.exports = {}",
      "string": "exports"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "test utility",
      "summary": "test utility",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4728,
    "codeStart": 4732,
    "code": "exports.test = require('./test');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "test",
      "value": "require('./test')",
      "string": "exports.test"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "type utility",
      "summary": "type utility",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4734,
    "codeStart": 4738,
    "code": "exports.type = require('type-detect');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "type",
      "value": "require('type-detect')",
      "string": "exports.type"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "expectTypes utility",
      "summary": "expectTypes utility",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4740,
    "codeStart": 4743,
    "code": "exports.expectTypes = require('./expectTypes');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "expectTypes",
      "value": "require('./expectTypes')",
      "string": "exports.expectTypes"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "message utility",
      "summary": "message utility",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4745,
    "codeStart": 4749,
    "code": "exports.getMessage = require('./getMessage');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "getMessage",
      "value": "require('./getMessage')",
      "string": "exports.getMessage"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "actual utility",
      "summary": "actual utility",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4751,
    "codeStart": 4755,
    "code": "exports.getActual = require('./getActual');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "getActual",
      "value": "require('./getActual')",
      "string": "exports.getActual"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Inspect util",
      "summary": "Inspect util",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4757,
    "codeStart": 4761,
    "code": "exports.inspect = require('./inspect');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "inspect",
      "value": "require('./inspect')",
      "string": "exports.inspect"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Object Display util",
      "summary": "Object Display util",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4763,
    "codeStart": 4767,
    "code": "exports.objDisplay = require('./objDisplay');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "objDisplay",
      "value": "require('./objDisplay')",
      "string": "exports.objDisplay"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Flag utility",
      "summary": "Flag utility",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4769,
    "codeStart": 4773,
    "code": "exports.flag = require('./flag');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "flag",
      "value": "require('./flag')",
      "string": "exports.flag"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Flag transferring utility",
      "summary": "Flag transferring utility",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4775,
    "codeStart": 4779,
    "code": "exports.transferFlags = require('./transferFlags');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "transferFlags",
      "value": "require('./transferFlags')",
      "string": "exports.transferFlags"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Deep equal utility",
      "summary": "Deep equal utility",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4781,
    "codeStart": 4785,
    "code": "exports.eql = require('deep-eql');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "eql",
      "value": "require('deep-eql')",
      "string": "exports.eql"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Deep path value",
      "summary": "Deep path value",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4787,
    "codeStart": 4791,
    "code": "exports.getPathValue = require('./getPathValue');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "getPathValue",
      "value": "require('./getPathValue')",
      "string": "exports.getPathValue"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Deep path info",
      "summary": "Deep path info",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4793,
    "codeStart": 4797,
    "code": "exports.getPathInfo = require('./getPathInfo');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "getPathInfo",
      "value": "require('./getPathInfo')",
      "string": "exports.getPathInfo"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Check if a property exists",
      "summary": "Check if a property exists",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4799,
    "codeStart": 4803,
    "code": "exports.hasProperty = require('./hasProperty');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "hasProperty",
      "value": "require('./hasProperty')",
      "string": "exports.hasProperty"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Function name",
      "summary": "Function name",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4805,
    "codeStart": 4809,
    "code": "exports.getName = require('./getName');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "getName",
      "value": "require('./getName')",
      "string": "exports.getName"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "add Property",
      "summary": "add Property",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4811,
    "codeStart": 4815,
    "code": "exports.addProperty = require('./addProperty');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "addProperty",
      "value": "require('./addProperty')",
      "string": "exports.addProperty"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "add Method",
      "summary": "add Method",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4817,
    "codeStart": 4821,
    "code": "exports.addMethod = require('./addMethod');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "addMethod",
      "value": "require('./addMethod')",
      "string": "exports.addMethod"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "overwrite Property",
      "summary": "overwrite Property",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4823,
    "codeStart": 4827,
    "code": "exports.overwriteProperty = require('./overwriteProperty');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "overwriteProperty",
      "value": "require('./overwriteProperty')",
      "string": "exports.overwriteProperty"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "overwrite Method",
      "summary": "overwrite Method",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4829,
    "codeStart": 4833,
    "code": "exports.overwriteMethod = require('./overwriteMethod');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "overwriteMethod",
      "value": "require('./overwriteMethod')",
      "string": "exports.overwriteMethod"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Add a chainable method",
      "summary": "Add a chainable method",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4835,
    "codeStart": 4839,
    "code": "exports.addChainableMethod = require('./addChainableMethod');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "addChainableMethod",
      "value": "require('./addChainableMethod')",
      "string": "exports.addChainableMethod"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Overwrite chainable method",
      "summary": "Overwrite chainable method",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4841,
    "codeStart": 4845,
    "code": "exports.overwriteChainableMethod = require('./overwriteChainableMethod');\n\n},{\"./addChainableMethod\":9,\"./addMethod\":10,\"./addProperty\":11,\"./expectTypes\":12,\"./flag\":13,\"./getActual\":14,\"./getMessage\":16,\"./getName\":17,\"./getPathInfo\":18,\"./getPathValue\":19,\"./hasProperty\":21,\"./inspect\":23,\"./objDisplay\":24,\"./overwriteChainableMethod\":25,\"./overwriteMethod\":26,\"./overwriteProperty\":27,\"./test\":28,\"./transferFlags\":29,\"deep-eql\":31,\"type-detect\":35}],23:[function(require,module,exports){\n// This is (almost) directly from Node.js utils\n// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js\n\nvar getName = require('./getName');\nvar getProperties = require('./getProperties');\nvar getEnumerableProperties = require('./getEnumerableProperties');\n\nmodule.exports = inspect;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "overwriteChainableMethod",
      "value": "require('./overwriteChainableMethod')",
      "string": "exports.overwriteChainableMethod"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} obj The object to print out.",
        "name": "obj",
        "description": "The object to print out.",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Boolean} showHidden Flag that shows hidden (not enumerable)\n   properties of objects.",
        "name": "showHidden",
        "description": "Flag that shows hidden (not enumerable)    properties of objects.",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} depth Depth in which to descend in object. Default is 2.",
        "name": "depth",
        "description": "Depth in which to descend in object. Default is 2.",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Boolean} colors Flag to turn on ANSI escape codes to color the\n   output. Default is false (no coloring).",
        "name": "colors",
        "description": "Flag to turn on ANSI escape codes to color the    output. Default is false (no coloring).",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "inspect"
      }
    ],
    "description": {
      "full": "Echos the value of a value. Trys to print the value out\nin the best way possible given the different types.",
      "summary": "Echos the value of a value. Trys to print the value out\nin the best way possible given the different types.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4857,
    "codeStart": 4870,
    "code": "function inspect(obj, showHidden, depth, colors) {\n  var ctx = {\n    showHidden: showHidden,\n    seen: [],\n    stylize: function (str) { return str; }\n  };\n  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));\n}\n\n// Returns true if object is a DOM element.\nvar isDOMElement = function (object) {\n  if (typeof HTMLElement === 'object') {\n    return object instanceof HTMLElement;\n  } else {\n    return object &&\n      typeof object === 'object' &&\n      object.nodeType === 1 &&\n      typeof object.nodeName === 'string';\n  }\n};\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (value && typeof value.inspect === 'function' &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes);\n    if (typeof ret !== 'string') {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // If this is a DOM element, try to get the outer HTML.\n  if (isDOMElement(value)) {\n    if ('outerHTML' in value) {\n      return value.outerHTML;\n      // This value does not have an outerHTML attribute,\n      //   it could still be an XML element\n    } else {\n      // Attempt to serialize it\n      try {\n        if (document.xmlVersion) {\n          var xmlSerializer = new XMLSerializer();\n          return xmlSerializer.serializeToString(value);\n        } else {\n          // Firefox 11- do not support outerHTML\n          //   It does, however, support innerHTML\n          //   Use the following to render the element\n          var ns = \"http://www.w3.org/1999/xhtml\";\n          var container = document.createElementNS(ns, '_');\n\n          container.appendChild(value.cloneNode(false));\n          html = container.innerHTML\n            .replace('><', '>' + value.innerHTML + '<');\n          container.innerHTML = '';\n          return html;\n        }\n      } catch (err) {\n        // This could be a non-native DOM implementation,\n        //   continue with the normal flow:\n        //   printing the element as if it is an object.\n      }\n    }\n  }\n\n  // Look up the keys of the object.\n  var visibleKeys = getEnumerableProperties(value);\n  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;\n\n  // Some type of object without properties can be shortcutted.\n  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,\n  // a `stack` plus `description` property; ignore those for consistency.\n  if (keys.length === 0 || (isError(value) && (\n      (keys.length === 1 && keys[0] === 'stack') ||\n      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')\n     ))) {\n    if (typeof value === 'function') {\n      var name = getName(value);\n      var nameSuffix = name ? ': ' + name : '';\n      return ctx.stylize('[Function' + nameSuffix + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (typeof value === 'function') {\n    var name = getName(value);\n    var nameSuffix = name ? ': ' + name : '';\n    base = ' [Function' + nameSuffix + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    return formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  switch (typeof value) {\n    case 'undefined':\n      return ctx.stylize('undefined', 'undefined');\n\n    case 'string':\n      var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                               .replace(/'/g, \"\\\\'\")\n                                               .replace(/\\\\\"/g, '\"') + '\\'';\n      return ctx.stylize(simple, 'string');\n\n    case 'number':\n      if (value === 0 && (1/value) === -Infinity) {\n        return ctx.stylize('-0', 'number');\n      }\n      return ctx.stylize('' + value, 'number');\n\n    case 'boolean':\n      return ctx.stylize('' + value, 'boolean');\n  }\n  // For some reason typeof null is \"object\", so special case here.\n  if (value === null) {\n    return ctx.stylize('null', 'null');\n  }\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (Object.prototype.hasOwnProperty.call(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str;\n  if (value.__lookupGetter__) {\n    if (value.__lookupGetter__(key)) {\n      if (value.__lookupSetter__(key)) {\n        str = ctx.stylize('[Getter/Setter]', 'special');\n      } else {\n        str = ctx.stylize('[Getter]', 'special');\n      }\n    } else {\n      if (value.__lookupSetter__(key)) {\n        str = ctx.stylize('[Setter]', 'special');\n      }\n    }\n  }\n  if (visibleKeys.indexOf(key) < 0) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(value[key]) < 0) {\n      if (recurseTimes === null) {\n        str = formatValue(ctx, value[key], null);\n      } else {\n        str = formatValue(ctx, value[key], recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (typeof name === 'undefined') {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\nfunction isArray(ar) {\n  return Array.isArray(ar) ||\n         (typeof ar === 'object' && objectToString(ar) === '[object Array]');\n}\n\nfunction isRegExp(re) {\n  return typeof re === 'object' && objectToString(re) === '[object RegExp]';\n}\n\nfunction isDate(d) {\n  return typeof d === 'object' && objectToString(d) === '[object Date]';\n}\n\nfunction isError(e) {\n  return typeof e === 'object' && objectToString(e) === '[object Error]';\n}\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n},{\"./getEnumerableProperties\":15,\"./getName\":17,\"./getProperties\":20}],24:[function(require,module,exports){",
    "ctx": {
      "type": "function",
      "name": "inspect",
      "string": "inspect()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - flag utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - flag utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5185,
    "codeStart": 5190
  },
  {
    "tags": [],
    "description": {
      "full": "Module dependancies",
      "summary": "Module dependancies",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5191,
    "codeStart": 5195,
    "code": "var inspect = require('./inspect');\nvar config = require('../config');",
    "ctx": {
      "type": "declaration",
      "name": "inspect",
      "value": "require('./inspect')",
      "string": "inspect"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} javascript object to inspect",
        "name": "javascript",
        "description": "object to inspect",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "name",
        "string": "objDisplay"
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .objDisplay (object)\n\nDetermines if an object or an array matches\ncriteria to be inspected in-line for error\nmessages or should be truncated.",
      "summary": "### .objDisplay (object)",
      "body": "Determines if an object or an array matches\ncriteria to be inspected in-line for error\nmessages or should be truncated."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5198,
    "codeStart": 5211,
    "code": "module.exports = function (obj) {\n  var str = inspect(obj)\n    , type = Object.prototype.toString.call(obj);\n\n  if (config.truncateThreshold && str.length >= config.truncateThreshold) {\n    if (type === '[object Function]') {\n      return !obj.name || obj.name === ''\n        ? '[Function]'\n        : '[Function: ' + obj.name + ']';\n    } else if (type === '[object Array]') {\n      return '[ Array(' + obj.length + ') ]';\n    } else if (type === '[object Object]') {\n      var keys = Object.keys(obj)\n        , kstr = keys.length > 2\n          ? keys.splice(0, 2).join(', ') + ', ...'\n          : keys.join(', ');\n      return '{ Object (' + kstr + ') }';\n    } else {\n      return str;\n    }\n  } else {\n    return str;\n  }\n};\n\n},{\"../config\":4,\"./inspect\":23}],25:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - overwriteChainableMethod utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - overwriteChainableMethod utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5237,
    "codeStart": 5242
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} ctx object whose method / property is to be overwritten",
        "name": "ctx",
        "description": "object whose method / property is to be overwritten",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} name of method / property to overwrite",
        "name": "name",
        "description": "of method / property to overwrite",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Function} method function that returns a function to be used for name",
        "name": "method",
        "description": "function that returns a function to be used for name",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Function} chainingBehavior function that returns a function to be used for property",
        "name": "chainingBehavior",
        "description": "function that returns a function to be used for property",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "overwriteChainableMethod"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### overwriteChainableMethod (ctx, name, method, chainingBehavior)\n\nOverwites an already existing chainable method\nand provides access to the previous function or\nproperty.  Must return functions to be used for\nname.\n\n    utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',\n      function (_super) {\n      }\n    , function (_super) {\n      }\n    );\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.overwriteChainableMethod('foo', fn, fn);\n\nThen can be used as any other assertion.\n\n    expect(myFoo).to.have.length(3);\n    expect(myFoo).to.have.length.above(3);",
      "summary": "### overwriteChainableMethod (ctx, name, method, chainingBehavior)",
      "body": "Overwites an already existing chainable method\nand provides access to the previous function or\nproperty.  Must return functions to be used for\nname.\n\n    utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',\n      function (_super) {\n      }\n    , function (_super) {\n      }\n    );\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.overwriteChainableMethod('foo', fn, fn);\n\nThen can be used as any other assertion.\n\n    expect(myFoo).to.have.length(3);\n    expect(myFoo).to.have.length.above(3);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5243,
    "codeStart": 5276,
    "code": "module.exports = function (ctx, name, method, chainingBehavior) {\n  var chainableBehavior = ctx.__methods[name];\n\n  var _chainingBehavior = chainableBehavior.chainingBehavior;\n  chainableBehavior.chainingBehavior = function () {\n    var result = chainingBehavior(_chainingBehavior).call(this);\n    return result === undefined ? this : result;\n  };\n\n  var _method = chainableBehavior.method;\n  chainableBehavior.method = function () {\n    var result = method(_method).apply(this, arguments);\n    return result === undefined ? this : result;\n  };\n};\n\n},{}],26:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - overwriteMethod utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - overwriteMethod utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5293,
    "codeStart": 5298
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} ctx object whose method is to be overwritten",
        "name": "ctx",
        "description": "object whose method is to be overwritten",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} name of method to overwrite",
        "name": "name",
        "description": "of method to overwrite",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Function} method function that returns a function to be used for name",
        "name": "method",
        "description": "function that returns a function to be used for name",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "overwriteMethod"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### overwriteMethod (ctx, name, fn)\n\nOverwites an already existing method and provides\naccess to previous function. Must return function\nto be used for name.\n\n    utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {\n      return function (str) {\n        var obj = utils.flag(this, 'object');\n        if (obj instanceof Foo) {\n          new chai.Assertion(obj.value).to.equal(str);\n        } else {\n          _super.apply(this, arguments);\n        }\n      }\n    });\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.overwriteMethod('foo', fn);\n\nThen can be used as any other assertion.\n\n    expect(myFoo).to.equal('bar');",
      "summary": "### overwriteMethod (ctx, name, fn)",
      "body": "Overwites an already existing method and provides\naccess to previous function. Must return function\nto be used for name.\n\n    utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {\n      return function (str) {\n        var obj = utils.flag(this, 'object');\n        if (obj instanceof Foo) {\n          new chai.Assertion(obj.value).to.equal(str);\n        } else {\n          _super.apply(this, arguments);\n        }\n      }\n    });\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.overwriteMethod('foo', fn);\n\nThen can be used as any other assertion.\n\n    expect(myFoo).to.equal('bar');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5299,
    "codeStart": 5333,
    "code": "module.exports = function (ctx, name, method) {\n  var _method = ctx[name]\n    , _super = function () { return this; };\n\n  if (_method && 'function' === typeof _method)\n    _super = _method;\n\n  ctx[name] = function () {\n    var result = method(_super).apply(this, arguments);\n    return result === undefined ? this : result;\n  }\n};\n\n},{}],27:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - overwriteProperty utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - overwriteProperty utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5347,
    "codeStart": 5352
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} ctx object whose property is to be overwritten",
        "name": "ctx",
        "description": "object whose property is to be overwritten",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} name of property to overwrite",
        "name": "name",
        "description": "of property to overwrite",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Function} getter function that returns a getter function to be used for name",
        "name": "getter",
        "description": "function that returns a getter function to be used for name",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "overwriteProperty"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### overwriteProperty (ctx, name, fn)\n\nOverwites an already existing property getter and provides\naccess to previous value. Must return function to use as getter.\n\n    utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {\n      return function () {\n        var obj = utils.flag(this, 'object');\n        if (obj instanceof Foo) {\n          new chai.Assertion(obj.name).to.equal('bar');\n        } else {\n          _super.call(this);\n        }\n      }\n    });\n\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.overwriteProperty('foo', fn);\n\nThen can be used as any other assertion.\n\n    expect(myFoo).to.be.ok;",
      "summary": "### overwriteProperty (ctx, name, fn)",
      "body": "Overwites an already existing property getter and provides\naccess to previous value. Must return function to use as getter.\n\n    utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {\n      return function () {\n        var obj = utils.flag(this, 'object');\n        if (obj instanceof Foo) {\n          new chai.Assertion(obj.name).to.equal('bar');\n        } else {\n          _super.call(this);\n        }\n      }\n    });\n\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.overwriteProperty('foo', fn);\n\nThen can be used as any other assertion.\n\n    expect(myFoo).to.be.ok;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5353,
    "codeStart": 5387,
    "code": "module.exports = function (ctx, name, getter) {\n  var _get = Object.getOwnPropertyDescriptor(ctx, name)\n    , _super = function () {};\n\n  if (_get && 'function' === typeof _get.get)\n    _super = _get.get\n\n  Object.defineProperty(ctx, name,\n    { get: function () {\n        var result = getter(_super).call(this);\n        return result === undefined ? this : result;\n      }\n    , configurable: true\n  });\n};\n\n},{}],28:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - test utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - test utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5404,
    "codeStart": 5409
  },
  {
    "tags": [],
    "description": {
      "full": "Module dependancies",
      "summary": "Module dependancies",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5410,
    "codeStart": 5414,
    "code": "var flag = require('./flag');",
    "ctx": {
      "type": "declaration",
      "name": "flag",
      "value": "require('./flag')",
      "string": "flag"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} object (constructed Assertion)",
        "name": "object",
        "description": "(constructed Assertion)",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Arguments} chai.Assertion.prototype.assert arguments",
        "name": "chai.Assertion.prototype.assert",
        "description": "arguments",
        "types": [
          "Arguments"
        ],
        "typesDescription": "<a href=\"Arguments.html\">Arguments</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "test"
      }
    ],
    "description": {
      "full": "# test(object, expression)\n\nTest and object for expression.",
      "summary": "# test(object, expression)",
      "body": "Test and object for expression."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5416,
    "codeStart": 5427,
    "code": "module.exports = function (obj, args) {\n  var negate = flag(obj, 'negate')\n    , expr = args[0];\n  return negate ? !expr : expr;\n};\n\n},{\"./flag\":13}],29:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - transferFlags utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - transferFlags utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5434,
    "codeStart": 5439
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Assertion} assertion the assertion to transfer the flags from",
        "name": "assertion",
        "description": "the assertion to transfer the flags from",
        "types": [
          "Assertion"
        ],
        "typesDescription": "<a href=\"Assertion.html\">Assertion</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object the object to transfer the flags to; usually a new assertion",
        "name": "object",
        "description": "the object to transfer the flags to; usually a new assertion",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Boolean} includeAll",
        "name": "includeAll",
        "description": "",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "transferFlags"
      },
      {
        "type": "api",
        "string": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "### transferFlags(assertion, object, includeAll = true)\n\nTransfer all the flags for `assertion` to `object`. If\n`includeAll` is set to `false`, then the base Chai\nassertion flags (namely `object`, `ssfi`, and `message`)\nwill not be transferred.\n\n\n    var newAssertion = new Assertion();\n    utils.transferFlags(assertion, newAssertion);\n\n    var anotherAsseriton = new Assertion(myObj);\n    utils.transferFlags(assertion, anotherAssertion, false);",
      "summary": "### transferFlags(assertion, object, includeAll = true)",
      "body": "Transfer all the flags for `assertion` to `object`. If\n`includeAll` is set to `false`, then the base Chai\nassertion flags (namely `object`, `ssfi`, and `message`)\nwill not be transferred.\n\n\n    var newAssertion = new Assertion();\n    utils.transferFlags(assertion, newAssertion);\n\n    var anotherAsseriton = new Assertion(myObj);\n    utils.transferFlags(assertion, anotherAssertion, false);"
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5440,
    "codeStart": 5463,
    "code": "module.exports = function (assertion, object, includeAll) {\n  var flags = assertion.__flags || (assertion.__flags = Object.create(null));\n\n  if (!object.__flags) {\n    object.__flags = Object.create(null);\n  }\n\n  includeAll = arguments.length === 3 ? includeAll : true;\n\n  for (var flag in flags) {\n    if (includeAll ||\n        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {\n      object.__flags[flag] = flags[flag];\n    }\n  }\n};\n\n},{}],30:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "assertion-error\nCopyright(c) 2013 Jake Luer <jake@qualiancy.com>\nMIT Licensed",
      "summary": "assertion-error\nCopyright(c) 2013 Jake Luer <jake@qualiancy.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5481,
    "codeStart": 5486
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{String} excluded properties ...",
        "name": "excluded",
        "description": "properties ...",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Function}",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": ""
      }
    ],
    "description": {
      "full": "Return a function that will copy properties from\none object to another excluding any originally\nlisted. Returned function will create a new `{}`.",
      "summary": "Return a function that will copy properties from\none object to another excluding any originally\nlisted. Returned function will create a new `{}`.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5487,
    "codeStart": 5496,
    "code": "function exclude () {\n  var excludes = [].slice.call(arguments);\n\n  function excludeProps (res, obj) {\n    Object.keys(obj).forEach(function (key) {\n      if (!~excludes.indexOf(key)) res[key] = obj[key];\n    });\n  }\n\n  return function extendExclude () {\n    var args = [].slice.call(arguments)\n      , i = 0\n      , res = {};\n\n    for (; i < args.length; i++) {\n      excludeProps(res, args[i]);\n    }\n\n    return res;\n  };\n};",
    "ctx": {
      "type": "function",
      "name": "exclude",
      "string": "exclude()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Primary Exports",
      "summary": "Primary Exports",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5518,
    "codeStart": 5522,
    "code": "module.exports = AssertionError;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "AssertionError",
      "string": "module.exports"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} properties to include (optional)",
        "name": "properties",
        "description": "to include (optional)",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{callee} start stack function (optional)",
        "name": "start",
        "description": "stack function (optional)",
        "types": [
          "callee"
        ],
        "typesDescription": "<a href=\"callee.html\">callee</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      }
    ],
    "description": {
      "full": "### AssertionError\n\nAn extension of the JavaScript `Error` constructor for\nassertion and validation scenarios.",
      "summary": "### AssertionError",
      "body": "An extension of the JavaScript `Error` constructor for\nassertion and validation scenarios."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5524,
    "codeStart": 5535,
    "code": "function AssertionError (message, _props, ssf) {\n  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')\n    , props = extend(_props || {});\n\n  // default values\n  this.message = message || 'Unspecified AssertionError';\n  this.showDiff = false;\n\n  // copy from properties\n  for (var key in props) {\n    this[key] = props[key];\n  }\n\n  // capture stack trace\n  ssf = ssf || arguments.callee;\n  if (ssf && Error.captureStackTrace) {\n    Error.captureStackTrace(this, ssf);\n  } else {\n    this.stack = new Error().stack;\n  }\n}",
    "ctx": {
      "type": "function",
      "name": "AssertionError",
      "string": "AssertionError()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Inherit from Error.prototype",
      "summary": "Inherit from Error.prototype",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5557,
    "codeStart": 5561,
    "code": "AssertionError.prototype = Object.create(Error.prototype);",
    "ctx": {
      "type": "property",
      "receiver": "AssertionError",
      "name": "prototype",
      "value": "Object.create(Error.prototype)",
      "string": "AssertionError.prototype"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Statically set name",
      "summary": "Statically set name",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5563,
    "codeStart": 5567,
    "code": "AssertionError.prototype.name = 'AssertionError';",
    "ctx": {
      "type": "property",
      "constructor": "AssertionError",
      "cons": "AssertionError",
      "name": "name",
      "value": "'AssertionError'",
      "string": "AssertionError.prototype.name"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Ensure correct constructor",
      "summary": "Ensure correct constructor",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5569,
    "codeStart": 5573,
    "code": "AssertionError.prototype.constructor = AssertionError;",
    "ctx": {
      "type": "property",
      "constructor": "AssertionError",
      "cons": "AssertionError",
      "name": "constructor",
      "value": "AssertionError",
      "string": "AssertionError.prototype.constructor"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Boolean} include stack (default: `true`)",
        "name": "include",
        "description": "stack (default: `true`)",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Object} object that can be `JSON.stringify`",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "object that can be `JSON.stringify`"
      }
    ],
    "description": {
      "full": "Allow errors to be converted to JSON for static transfer.",
      "summary": "Allow errors to be converted to JSON for static transfer.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5575,
    "codeStart": 5582,
    "code": "AssertionError.prototype.toJSON = function (stack) {\n  var extend = exclude('constructor', 'toJSON', 'stack')\n    , props = extend({ name: this.name }, this);\n\n  // include stack if exists and not turned off\n  if (false !== stack && this.stack) {\n    props.stack = this.stack;\n  }\n\n  return props;\n};\n\n},{}],31:[function(require,module,exports){\nmodule.exports = require('./lib/eql');\n\n},{\"./lib/eql\":32}],32:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "constructor": "AssertionError",
      "cons": "AssertionError",
      "name": "toJSON",
      "string": "AssertionError.prototype.toJSON()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "deep-eql\nCopyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "deep-eql\nCopyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5598,
    "codeStart": 5603
  },
  {
    "tags": [],
    "description": {
      "full": "Module dependencies",
      "summary": "Module dependencies",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5604,
    "codeStart": 5608,
    "code": "var type = require('type-detect');",
    "ctx": {
      "type": "declaration",
      "name": "type",
      "value": "require('type-detect')",
      "string": "type"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Buffer.isBuffer browser shim",
      "summary": "Buffer.isBuffer browser shim",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5610,
    "codeStart": 5614,
    "code": "var Buffer;\ntry { Buffer = require('buffer').Buffer; }\ncatch(ex) {\n  Buffer = {};\n  Buffer.isBuffer = function() { return false; }\n}",
    "ctx": false
  },
  {
    "tags": [],
    "description": {
      "full": "Primary Export",
      "summary": "Primary Export",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5621,
    "codeStart": 5625,
    "code": "module.exports = deepEqual;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "deepEqual",
      "string": "module.exports"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} a",
        "name": "a",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} b",
        "name": "b",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} memoised (optional)",
        "name": "memoised",
        "description": "(optional)",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} equal match",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "equal match"
      }
    ],
    "description": {
      "full": "Assert super-strict (egal) equality between\ntwo objects of any type.",
      "summary": "Assert super-strict (egal) equality between\ntwo objects of any type.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5627,
    "codeStart": 5637,
    "code": "function deepEqual(a, b, m) {\n  if (sameValue(a, b)) {\n    return true;\n  } else if ('date' === type(a)) {\n    return dateEqual(a, b);\n  } else if ('regexp' === type(a)) {\n    return regexpEqual(a, b);\n  } else if (Buffer.isBuffer(a)) {\n    return bufferEqual(a, b);\n  } else if ('arguments' === type(a)) {\n    return argumentsEqual(a, b, m);\n  } else if (!typeEqual(a, b)) {\n    return false;\n  } else if (('object' !== type(a) && 'object' !== type(b))\n  && ('array' !== type(a) && 'array' !== type(b))) {\n    return sameValue(a, b);\n  } else {\n    return objectEqual(a, b, m);\n  }\n}",
    "ctx": {
      "type": "function",
      "name": "deepEqual",
      "string": "deepEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} a",
        "name": "a",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} b",
        "name": "b",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} equal match",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "equal match"
      }
    ],
    "description": {
      "full": "Strict (egal) equality test. Ensures that NaN always\nequals NaN and `-0` does not equal `+0`.",
      "summary": "Strict (egal) equality test. Ensures that NaN always\nequals NaN and `-0` does not equal `+0`.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5658,
    "codeStart": 5667,
    "code": "function sameValue(a, b) {\n  if (a === b) return a !== 0 || 1 / a === 1 / b;\n  return a !== a && b !== b;\n}",
    "ctx": {
      "type": "function",
      "name": "sameValue",
      "string": "sameValue()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} a",
        "name": "a",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} b",
        "name": "b",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} result",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "result"
      }
    ],
    "description": {
      "full": "Compare the types of two given objects and\nreturn if they are equal. Note that an Array\nhas a type of `array` (not `object`) and arguments\nhave a type of `arguments` (not `array`/`object`).",
      "summary": "Compare the types of two given objects and\nreturn if they are equal. Note that an Array\nhas a type of `array` (not `object`) and arguments\nhave a type of `arguments` (not `array`/`object`).",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5672,
    "codeStart": 5683,
    "code": "function typeEqual(a, b) {\n  return type(a) === type(b);\n}",
    "ctx": {
      "type": "function",
      "name": "typeEqual",
      "string": "typeEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Date} a",
        "name": "a",
        "description": "",
        "types": [
          "Date"
        ],
        "typesDescription": "<code>Date</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Date} b",
        "name": "b",
        "description": "",
        "types": [
          "Date"
        ],
        "typesDescription": "<code>Date</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} result",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "result"
      }
    ],
    "description": {
      "full": "Compare two Date objects by asserting that\nthe time values are equal using `saveValue`.",
      "summary": "Compare two Date objects by asserting that\nthe time values are equal using `saveValue`.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5687,
    "codeStart": 5696,
    "code": "function dateEqual(a, b) {\n  if ('date' !== type(b)) return false;\n  return sameValue(a.getTime(), b.getTime());\n}",
    "ctx": {
      "type": "function",
      "name": "dateEqual",
      "string": "dateEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{RegExp} a",
        "name": "a",
        "description": "",
        "types": [
          "RegExp"
        ],
        "typesDescription": "<code>RegExp</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{RegExp} b",
        "name": "b",
        "description": "",
        "types": [
          "RegExp"
        ],
        "typesDescription": "<code>RegExp</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} result",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "result"
      }
    ],
    "description": {
      "full": "Compare two regular expressions by converting them\nto string and checking for `sameValue`.",
      "summary": "Compare two regular expressions by converting them\nto string and checking for `sameValue`.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5701,
    "codeStart": 5710,
    "code": "function regexpEqual(a, b) {\n  if ('regexp' !== type(b)) return false;\n  return sameValue(a.toString(), b.toString());\n}",
    "ctx": {
      "type": "function",
      "name": "regexpEqual",
      "string": "regexpEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Arguments} a",
        "name": "a",
        "description": "",
        "types": [
          "Arguments"
        ],
        "typesDescription": "<a href=\"Arguments.html\">Arguments</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Arguments} b",
        "name": "b",
        "description": "",
        "types": [
          "Arguments"
        ],
        "typesDescription": "<a href=\"Arguments.html\">Arguments</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} memoize (optional)",
        "name": "memoize",
        "description": "(optional)",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} result",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "result"
      }
    ],
    "description": {
      "full": "Assert deep equality of two `arguments` objects.\nUnfortunately, these must be sliced to arrays\nprior to test to ensure no bad behavior.",
      "summary": "Assert deep equality of two `arguments` objects.\nUnfortunately, these must be sliced to arrays\nprior to test to ensure no bad behavior.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5715,
    "codeStart": 5726,
    "code": "function argumentsEqual(a, b, m) {\n  if ('arguments' !== type(b)) return false;\n  a = [].slice.call(a);\n  b = [].slice.call(b);\n  return deepEqual(a, b, m);\n}",
    "ctx": {
      "type": "function",
      "name": "argumentsEqual",
      "string": "argumentsEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} a",
        "name": "a",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Array} property names",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "property names"
      }
    ],
    "description": {
      "full": "Get enumerable properties of a given object.",
      "summary": "Get enumerable properties of a given object.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5733,
    "codeStart": 5740,
    "code": "function enumerable(a) {\n  var res = [];\n  for (var key in a) res.push(key);\n  return res;\n}",
    "ctx": {
      "type": "function",
      "name": "enumerable",
      "string": "enumerable()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Iterable} a",
        "name": "a",
        "description": "",
        "types": [
          "Iterable"
        ],
        "typesDescription": "<a href=\"Iterable.html\">Iterable</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Iterable} b",
        "name": "b",
        "description": "",
        "types": [
          "Iterable"
        ],
        "typesDescription": "<a href=\"Iterable.html\">Iterable</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} result",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "result"
      }
    ],
    "description": {
      "full": "Simple equality for flat iterable objects\nsuch as Arrays or Node.js buffers.",
      "summary": "Simple equality for flat iterable objects\nsuch as Arrays or Node.js buffers.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5746,
    "codeStart": 5755,
    "code": "function iterableEqual(a, b) {\n  if (a.length !==  b.length) return false;\n\n  var i = 0;\n  var match = true;\n\n  for (; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      match = false;\n      break;\n    }\n  }\n\n  return match;\n}",
    "ctx": {
      "type": "function",
      "name": "iterableEqual",
      "string": "iterableEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Buffer} a",
        "name": "a",
        "description": "",
        "types": [
          "Buffer"
        ],
        "typesDescription": "<a href=\"Buffer.html\">Buffer</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} b",
        "name": "b",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} result",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "result"
      }
    ],
    "description": {
      "full": "Extension to `iterableEqual` specifically\nfor Node.js Buffers.",
      "summary": "Extension to `iterableEqual` specifically\nfor Node.js Buffers.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5771,
    "codeStart": 5780,
    "code": "function bufferEqual(a, b) {\n  if (!Buffer.isBuffer(b)) return false;\n  return iterableEqual(a, b);\n}",
    "ctx": {
      "type": "function",
      "name": "bufferEqual",
      "string": "bufferEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} object",
        "name": "object",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} result",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "result"
      }
    ],
    "description": {
      "full": "Block for `objectEqual` ensuring non-existing\nvalues don't get in.",
      "summary": "Block for `objectEqual` ensuring non-existing\nvalues don't get in.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5785,
    "codeStart": 5793,
    "code": "function isValue(a) {\n  return a !== null && a !== undefined;\n}",
    "ctx": {
      "type": "function",
      "name": "isValue",
      "string": "isValue()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} a",
        "name": "a",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} b",
        "name": "b",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} result",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "result"
      }
    ],
    "description": {
      "full": "Recursively check the equality of two objects.\nOnce basic sameness has been established it will\ndefer to `deepEqual` for each enumerable key\nin the object.",
      "summary": "Recursively check the equality of two objects.\nOnce basic sameness has been established it will\ndefer to `deepEqual` for each enumerable key\nin the object.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5797,
    "codeStart": 5808,
    "code": "function objectEqual(a, b, m) {\n  if (!isValue(a) || !isValue(b)) {\n    return false;\n  }\n\n  if (a.prototype !== b.prototype) {\n    return false;\n  }\n\n  var i;\n  if (m) {\n    for (i = 0; i < m.length; i++) {\n      if ((m[i][0] === a && m[i][1] === b)\n      ||  (m[i][0] === b && m[i][1] === a)) {\n        return true;\n      }\n    }\n  } else {\n    m = [];\n  }\n\n  try {\n    var ka = enumerable(a);\n    var kb = enumerable(b);\n  } catch (ex) {\n    return false;\n  }\n\n  ka.sort();\n  kb.sort();\n\n  if (!iterableEqual(ka, kb)) {\n    return false;\n  }\n\n  m.push([ a, b ]);\n\n  var key;\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], m)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n},{\"buffer\":undefined,\"type-detect\":33}],33:[function(require,module,exports){\nmodule.exports = require('./lib/type');\n\n},{\"./lib/type\":34}],34:[function(require,module,exports){",
    "ctx": {
      "type": "function",
      "name": "objectEqual",
      "string": "objectEqual()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "type-detect\nCopyright(c) 2013 jake luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "type-detect\nCopyright(c) 2013 jake luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5860,
    "codeStart": 5865
  },
  {
    "tags": [],
    "description": {
      "full": "Primary Exports",
      "summary": "Primary Exports",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5866,
    "codeStart": 5870,
    "code": "var exports = module.exports = getType;",
    "ctx": {
      "type": "declaration",
      "name": "exports",
      "value": "module.exports = getType",
      "string": "exports"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Detectable javascript natives",
      "summary": "Detectable javascript natives",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5872,
    "codeStart": 5876,
    "code": "var natives = {\n    '[object Array]': 'array'\n  , '[object RegExp]': 'regexp'\n  , '[object Function]': 'function'\n  , '[object Arguments]': 'arguments'\n  , '[object Date]': 'date'\n};",
    "ctx": {
      "type": "declaration",
      "name": "natives",
      "value": "{",
      "string": "natives"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} object",
        "name": "object",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{String} object type",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "object type"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### typeOf (obj)\n\nUse several different techniques to determine\nthe type of object being tested.",
      "summary": "### typeOf (obj)",
      "body": "Use several different techniques to determine\nthe type of object being tested."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5884,
    "codeStart": 5896,
    "code": "function getType (obj) {\n  var str = Object.prototype.toString.call(obj);\n  if (natives[str]) return natives[str];\n  if (obj === null) return 'null';\n  if (obj === undefined) return 'undefined';\n  if (obj === Object(obj)) return 'object';\n  return typeof obj;\n}\n\nexports.Library = Library;",
    "ctx": {
      "type": "function",
      "name": "getType",
      "string": "getType()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "### Library\n\nCreate a repository for custom type detection.\n\n```js\nvar lib = new type.Library;\n```",
      "summary": "### Library",
      "body": "Create a repository for custom type detection.\n\n```js\nvar lib = new type.Library;\n```"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5907,
    "codeStart": 5918,
    "code": "function Library () {\n  this.tests = {};\n}",
    "ctx": {
      "type": "function",
      "name": "Library",
      "string": "Library()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} object to test",
        "name": "object",
        "description": "to test",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{String} type",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "type"
      }
    ],
    "description": {
      "full": "#### .of (obj)\n\nExpose replacement `typeof` detection to the library.\n\n```js\nif ('string' === lib.of('hello world')) {\n  // ...\n}\n```",
      "summary": "#### .of (obj)",
      "body": "Expose replacement `typeof` detection to the library.\n\n```js\nif ('string' === lib.of('hello world')) {\n  // ...\n}\n```"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5922,
    "codeStart": 5937,
    "code": "Library.prototype.of = getType;",
    "ctx": {
      "type": "property",
      "constructor": "Library",
      "cons": "Library",
      "name": "of",
      "value": "getType",
      "string": "Library.prototype.of"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{String} type",
        "name": "type",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{RegExp|Function} test",
        "name": "test",
        "description": "",
        "types": [
          "RegExp",
          "Function"
        ],
        "typesDescription": "<code>RegExp</code>|<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "#### .define (type, test)\n\nAdd a test to for the `.test()` assertion.\n\nCan be defined as a regular expression:\n\n```js\nlib.define('int', /^[0-9]+$/);\n```\n\n... or as a function:\n\n```js\nlib.define('bln', function (obj) {\n  if ('boolean' === lib.of(obj)) return true;\n  var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];\n  if ('string' === lib.of(obj)) obj = obj.toLowerCase();\n  return !! ~blns.indexOf(obj);\n});\n```",
      "summary": "#### .define (type, test)",
      "body": "Add a test to for the `.test()` assertion.\n\nCan be defined as a regular expression:\n\n```js\nlib.define('int', /^[0-9]+$/);\n```\n\n... or as a function:\n\n```js\nlib.define('bln', function (obj) {\n  if ('boolean' === lib.of(obj)) return true;\n  var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];\n  if ('string' === lib.of(obj)) obj = obj.toLowerCase();\n  return !! ~blns.indexOf(obj);\n});\n```"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5939,
    "codeStart": 5966,
    "code": "Library.prototype.define = function (type, test) {\n  if (arguments.length === 1) return this.tests[type];\n  this.tests[type] = test;\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Library",
      "cons": "Library",
      "name": "define",
      "string": "Library.prototype.define()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} object",
        "name": "object",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} type",
        "name": "type",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} result",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "result"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "#### .test (obj, test)\n\nAssert that an object is of type. Will first\ncheck natives, and if that does not pass it will\nuse the user defined custom tests.\n\n```js\nassert(lib.test('1', 'int'));\nassert(lib.test('yes', 'bln'));\n```",
      "summary": "#### .test (obj, test)",
      "body": "Assert that an object is of type. Will first\ncheck natives, and if that does not pass it will\nuse the user defined custom tests.\n\n```js\nassert(lib.test('1', 'int'));\nassert(lib.test('yes', 'bln'));\n```"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5972,
    "codeStart": 5990,
    "code": "Library.prototype.test = function (obj, type) {\n  if (type === getType(obj)) return true;\n  var test = this.tests[type];\n\n  if (test && 'regexp' === getType(test)) {\n    return test.test(obj);\n  } else if (test && 'function' === getType(test)) {\n    return test(obj);\n  } else {\n    throw new ReferenceError('Type test \"' + type + '\" not defined or invalid.');\n  }\n};\n\n},{}],35:[function(require,module,exports){\narguments[4][33][0].apply(exports,arguments)\n},{\"./lib/type\":36,\"dup\":33}],36:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "constructor": "Library",
      "cons": "Library",
      "name": "test",
      "string": "Library.prototype.test()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "type-detect\nCopyright(c) 2013 jake luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "type-detect\nCopyright(c) 2013 jake luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 6006,
    "codeStart": 6011
  },
  {
    "tags": [],
    "description": {
      "full": "Primary Exports",
      "summary": "Primary Exports",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 6012,
    "codeStart": 6016,
    "code": "var exports = module.exports = getType;",
    "ctx": {
      "type": "declaration",
      "name": "exports",
      "value": "module.exports = getType",
      "string": "exports"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} object",
        "name": "object",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{String} object type",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "object type"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### typeOf (obj)\n\nUse several different techniques to determine\nthe type of object being tested.",
      "summary": "### typeOf (obj)",
      "body": "Use several different techniques to determine\nthe type of object being tested."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6018,
    "codeStart": 6029,
    "code": "var objectTypeRegexp = /^\\[object (.*)\\]$/;\n\nfunction getType(obj) {\n  var type = Object.prototype.toString.call(obj).match(objectTypeRegexp)[1].toLowerCase();\n  // Let \"new String('')\" return 'object'\n  if (typeof Promise === 'function' && obj instanceof Promise) return 'promise';\n  // PhantomJS has type \"DOMWindow\" for null\n  if (obj === null) return 'null';\n  // PhantomJS has type \"DOMWindow\" for undefined\n  if (obj === undefined) return 'undefined';\n  return type;\n}\n\nexports.Library = Library;",
    "ctx": {
      "type": "declaration",
      "name": "objectTypeRegexp",
      "value": "/^\\[object (.*)\\]$/",
      "string": "objectTypeRegexp"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "### Library\n\nCreate a repository for custom type detection.\n\n```js\nvar lib = new type.Library;\n```",
      "summary": "### Library",
      "body": "Create a repository for custom type detection.\n\n```js\nvar lib = new type.Library;\n```"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6044,
    "codeStart": 6055,
    "code": "function Library() {\n  if (!(this instanceof Library)) return new Library();\n  this.tests = {};\n}",
    "ctx": {
      "type": "function",
      "name": "Library",
      "string": "Library()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} object to test",
        "name": "object",
        "description": "to test",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{String} type",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "type"
      }
    ],
    "description": {
      "full": "#### .of (obj)\n\nExpose replacement `typeof` detection to the library.\n\n```js\nif ('string' === lib.of('hello world')) {\n  // ...\n}\n```",
      "summary": "#### .of (obj)",
      "body": "Expose replacement `typeof` detection to the library.\n\n```js\nif ('string' === lib.of('hello world')) {\n  // ...\n}\n```"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6060,
    "codeStart": 6075,
    "code": "Library.prototype.of = getType;",
    "ctx": {
      "type": "property",
      "constructor": "Library",
      "cons": "Library",
      "name": "of",
      "value": "getType",
      "string": "Library.prototype.of"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{String} type",
        "name": "type",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{RegExp|Function} test",
        "name": "test",
        "description": "",
        "types": [
          "RegExp",
          "Function"
        ],
        "typesDescription": "<code>RegExp</code>|<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "#### .define (type, test)\n\nAdd a test to for the `.test()` assertion.\n\nCan be defined as a regular expression:\n\n```js\nlib.define('int', /^[0-9]+$/);\n```\n\n... or as a function:\n\n```js\nlib.define('bln', function (obj) {\n  if ('boolean' === lib.of(obj)) return true;\n  var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];\n  if ('string' === lib.of(obj)) obj = obj.toLowerCase();\n  return !! ~blns.indexOf(obj);\n});\n```",
      "summary": "#### .define (type, test)",
      "body": "Add a test to for the `.test()` assertion.\n\nCan be defined as a regular expression:\n\n```js\nlib.define('int', /^[0-9]+$/);\n```\n\n... or as a function:\n\n```js\nlib.define('bln', function (obj) {\n  if ('boolean' === lib.of(obj)) return true;\n  var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];\n  if ('string' === lib.of(obj)) obj = obj.toLowerCase();\n  return !! ~blns.indexOf(obj);\n});\n```"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6077,
    "codeStart": 6104,
    "code": "Library.prototype.define = function(type, test) {\n  if (arguments.length === 1) return this.tests[type];\n  this.tests[type] = test;\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Library",
      "cons": "Library",
      "name": "define",
      "string": "Library.prototype.define()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} object",
        "name": "object",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} type",
        "name": "type",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} result",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "result"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "#### .test (obj, test)\n\nAssert that an object is of type. Will first\ncheck natives, and if that does not pass it will\nuse the user defined custom tests.\n\n```js\nassert(lib.test('1', 'int'));\nassert(lib.test('yes', 'bln'));\n```",
      "summary": "#### .test (obj, test)",
      "body": "Assert that an object is of type. Will first\ncheck natives, and if that does not pass it will\nuse the user defined custom tests.\n\n```js\nassert(lib.test('1', 'int'));\nassert(lib.test('yes', 'bln'));\n```"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6110,
    "codeStart": 6128,
    "code": "Library.prototype.test = function(obj, type) {\n  if (type === getType(obj)) return true;\n  var test = this.tests[type];\n\n  if (test && 'regexp' === getType(test)) {\n    return test.test(obj);\n  } else if (test && 'function' === getType(test)) {\n    return test(obj);\n  } else {\n    throw new ReferenceError('Type test \"' + type + '\" not defined or invalid.');\n  }\n};\n\n},{}]},{},[1])(1)\n});",
    "ctx": {
      "type": "method",
      "constructor": "Library",
      "cons": "Library",
      "name": "test",
      "string": "Library.prototype.test()"
    }
  }
]